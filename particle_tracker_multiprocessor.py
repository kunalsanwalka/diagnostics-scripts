# -*- coding: utf-8 -*-
"""
Created on Tue Nov 23 10:23:42 2021

@author: kunal

This program tracks the position of the particle through a magnetic field.

The magnetic field data is pulled from an eqdsk generated by pleiades.
"""

import sys
sys.path.insert(1,'C:/Users/kunal/OneDrive - UW-Madison/WHAM/Python Scripts/')

import os
import numpy as np
import scipy.constants as const
import matplotlib.pyplot as plt
import eqdsk_analysis_toolbox as eqTools
import cql3d_analysis_toolbox as cqlTools
from scipy.interpolate import RegularGridInterpolator
from scipy.integrate import solve_ivp
from scipy.spatial.transform import Rotation as R
from mpl_toolkits import mplot3d
from multiprocessing import Pool
from itertools import repeat

# =============================================================================
# Plot Directory
# =============================================================================
plotDest='C:/Users/kunal/OneDrive - UW-Madison/WHAM/Plots/'

# =============================================================================
# Data Directory
# =============================================================================
dataDest='C:/Users/kunal/OneDrive - UW-Madison/WHAM/Data/'

# =============================================================================
# Magnetic field data location
# =============================================================================
filenameEqdsk='C:/Users/kunal/OneDrive - UW-Madison/WHAM/Data/eqdsk/WHAM_Phase_2_eqdsk'

# =============================================================================
# Field interpolation functions
# =============================================================================

#Field values
Rmesh,Zmesh,Br,Bz,Bmag=eqTools.magnetic_field_RZ(filenameEqdsk)

#Interpolation function for magnetic field data
#Converts the grid data into a function which can return Br and Bz at any
#given (r,z)
global BzInterpolator,BrInterpolator,BmagInterpolator
BzInterpolator=RegularGridInterpolator((Zmesh[:,0],Rmesh[0]),Bz)
BrInterpolator=RegularGridInterpolator((Zmesh[:,0],Rmesh[0]),Br)
BmagInterpolator=RegularGridInterpolator((Zmesh[:,0],Rmesh[0]),Bmag)

def charge_to_mass_ratio(species):
    """
    This function calculates the charge to mass ratio for a given species.
    
    Available Species (Code)
    1.  Hydrogen (H)
    2.  Deuterium (D)
    3.  Tritium (T)
    4.  Helium-3 (He3)
    5.  Helium-4 (He4)
    6.  TR Hydrogen (-H)
    7.  TR Deuterium (-D)
    8.  TR Tritium (-T)
    9.  TR Helium-3 (-He3)
    10. TR Helium-4 (-He4)
    
    The ones labelled as time reveral (TR) have the opposite charge. This is so
    we can track their orbits backwards in time while using the same
    integrating functions.

    Parameters
    ----------
    species : string
        Species code.

    Returns
    -------
    qm : float
        Charge to mass ratio (C/kg).
    """
    
    #Initialize
    qm=0
    
    if species=='H':
        qm=const.e/const.m_p
    elif species=='D':
        qm=const.e/(const.m_n+const.m_p)
    elif species=='T':
        qm=const.e/(2*const.m_n+const.m_p)
    elif species=='He3':
        qm=2*const.e/(const.m_n+2*const.m_p)
    elif species=='He4':
        qm=2*const.e/(2*const.m_n+2*const.m_p)
    elif species=='-H':
        qm=-const.e/const.m_p
    elif species=='-D':
        qm=-const.e/(const.m_n+const.m_p)
    elif species=='-T':
        qm=-const.e/(2*const.m_n+const.m_p)
    elif species=='-He3':
        qm=-2*const.e/(const.m_n+2*const.m_p)
    elif species=='-He4':
        qm=-2*const.e/(2*const.m_n+2*const.m_p)
    
    return qm

def particle_mass(species):
    """
    This function calculates the mass of the particle for a given species.
    
    Available Species (Code)
    1.  Hydrogen (H)
    2.  Deuterium (D)
    3.  Tritium (T)
    4.  Helium-3 (He3)
    5.  Helium-4 (He4)
    6.  TR Hydrogen (-H)
    7.  TR Deuterium (-D)
    8.  TR Tritium (-T)
    9.  TR Helium-3 (-He3)
    10. TR Helium-4 (-He4)
    
    The ones labelled at time reversal (TR) are used for orbit tracking
    backwards in time. The mass does not change in this case.

    Parameters
    ----------
    species : string
        Species code.

    Returns
    -------
    m : float
        Mass of the species (in kg).
    """
    
    #Initalize
    m=0
    
    if species=='H' or species=='-H':
        m=const.m_p
    elif species=='D' or species=='-D':
        m=const.m_n+const.m_p
    elif species=='T' or species=='-T':
        m=2*const.m_n+const.m_p
    elif species=='He3' or species=='-He3':
        m=const.m_n+2*const.m_p
    elif species=='He4' or species=='-He4':
        m=2*const.m_n+2*const.m_p
    
    return m

def initialize_particle(energy,theta,phi=0,species='D'):
    """
    This function converts energy and the angles to the cartesian components
    of the velocity vector.

    Parameters
    ----------
    energy : float
        Energy of the particle (eV).
    theta : float
        Angle with the z-axis (radians).
    phi : float, optional
        Angle with the x-axis (radians).
        The default is 0.
    species : string, optional
        Species code. 
        The default is 'D'.

    Returns
    -------
    velArr : np.array
        Initial velocty of the particle in cartesian coordinates (m/s).
    """
    
    #Convert energy to Joules
    eJ=energy*const.e
    
    #Mass of the particle
    m=particle_mass(species)
        
    #Magnitude of the velocity
    velMag=np.sqrt(2*eJ/m)
    
    #Cartesian conponents of each velocity
    vx=velMag*np.sin(theta)*np.cos(phi)
    vy=velMag*np.sin(theta)*np.sin(phi)
    vz=velMag*np.cos(theta)
    
    velArr=np.array([vx,vy,vz])
    
    return velArr

def single_particle_track(xIni,energy,theta,phi=0,species='H'):
    """
    This function tracks the motion of the particle through the magnetic field
    as a function of the inital position and velocity.
    
    This is done with the help of the solve_ivp function from scipy. It is used
    to solve an initial value problem for ODE's. The exact syntax of it is
    complicated but it seems to be a 1 line affair. solve_ivp solves
    differential equations of the form-
    dy/dt=f(y,t)
    
    Orbit tracking is done by solving the Lorentz force equation in a magnetic
    field-
    a=(q/m)*(v x B)
    
    solve_ivp takes the Lorentz force equation written with velocities-
    vdot=(q/m)*(v x B)
    
    This along with the initial position and velocity (inferred from the 
    energy, theta and phi) gives the value of the state vector (position and 
    velocity) at all times.

    Parameters
    ----------
    xIni : np.array
        Initial position of the particle.
        Shape- xIni=[x0,y0,z0]
    energy : float
        Energy of the particle (eV).
    theta : float
        Angle with the z-axis (radians).
    phi : float, optional
        Angle with the x-axis (radians).
        The default is 0.
    species : string, optional
        Species code. 
        The default is 'H'.

    Returns
    -------
    stateVec : np.array
        State vector as a function of time (positions and velocities).
        Shape- stateVec[0]=x(t)
               stateVec[1]=y(t)
               stateVec[2]=z(t)
               stateVec[3]=vx(t)
               stateVec[4]=vy(t)
               stateVec[5]=vz(t)
    """
    
    #Number of timesteps
    timesteps=10000
    
    #Length of each timestep
    steplength=1e-9 #seconds
    
    #Total time for the integration
    totTime=timesteps*steplength
    
    #Get the initial velocity of the particle in cartesian coordinates
    vIni=initialize_particle(energy,theta,phi=phi,species=species)
    
    #Initial conditions array
    initCond=np.concatenate((xIni,vIni))
    
    #Solve the inital value problem for the position and velocity
    stateVec=solve_ivp(fun=integrand,                           #f(y,t)
                       t_span=(0,totTime),                      #Time domain over which we want the solution
                       y0=initCond,                             #Initial conditions
                       t_eval=np.linspace(0,totTime,timesteps), #Timesteps at which to save the state vector
                       args=species)                            #Other arguments in 'integrand'
    
    return stateVec.y

def integrand(t,y,species='D'):
    """
    This function is the integrand used by the solve_ivp function called in
    single_particle_track. This is done as scipy already has a built in initial
    value problem integrator which is more accurate than anything I can write.

    Parameters
    ----------
    t : float
        Time (s).
    y : np.array
        State vector (positions and velocities).
        Shape- y[0]=x
               y[1]=y
               y[2]=z
               y[3]=vx
               y[4]=vy
               y[5]=vz
    species : string, optional
        Species code. 
        The default is 'D'.

    Returns
    -------
    dvdt : np.array
        dy/dt (velocity and acceleration).
        Shape- dvdt[0]=vx
               dvdt[1]=vy
               dvdt[2]=vz
               dvdt[3]=ax
               dvdt[4]=ay
               dvdt[5]=az
    """
    
    #Positions
    xPos=y[0]
    yPos=y[1]
    zPos=y[2]
    
    #Velocities
    vx=y[3]
    vy=y[4]
    vz=y[5]
    
    #Convert x,y to cylindrical
    r=np.sqrt(xPos**2+yPos**2)
    theta=np.arctan2(yPos,xPos)
    
    #Try-except block since the particle can go beyond the range of the
    #generated eqdsk. If this were to happen to a real particle it would have
    #hit the wall anyway so just set v and a to 0.
    try:
        #Get Br and Bz at those points
        Br=BrInterpolator([zPos,r])[0]
        Bz=BzInterpolator([zPos,r])[0]
        
    except ValueError:
        Br=0
        Bz=0
        vx=0
        vy=0
        vz=0
    
    #Convert Br to Bx and By
    Bx=Br*np.cos(theta)
    By=Br*np.sin(theta)
    
    #Charge to mass ratio
    qm=charge_to_mass_ratio(species)
    
    #Calculate acceleration
    dvdt=[vx,               #vx
          vy,               #vy
          vz,               #vz
          qm*(vy*Bz-vz*By), #ax
          qm*(vz*Bx-vx*Bz), #ay
          qm*(vx*By-vy*Bx)] #az
    
    return dvdt

def generate_tracks_eqdsk(filename,species='H',makeplot=False,saveplot=False):
    """
    This function generates the fusion proton particle tracks for a given
    eqdsk output. The number of protons across z is uniform.

    Parameters
    ----------
    filename : string
        Name of the CQL3D output file.
    species : string, optional
        Fusion product species. 
        The default is 'H'.
    makeplot : boolean, optional
        Make a plot of the data.
    saveplot : boolean, optional
        Save the plot.

    Returns
    -------
    particleTracks : np.array
        Data on the state vector for each fusion proton.
    """
    
    #Initial energy
    energy=3.02e6 #eV
    
    #eqdsk mesh arrays
    Rmesh,Zmesh,eqdsk_psi=eqTools.flux_surfaces(filename=filename)
    
    #z limits
    zMax=np.max(Zmesh)
    zMin=np.min(Zmesh)
    
    #z array
    zArr=np.linspace(zMin,zMax,100)
    
    #Construct the theta array
    thetaArr=np.linspace(0,2*np.pi,10)
    
    #Construct the phi array
    phiArr=np.linspace(0,np.pi,10)
    
    #Get the particle tracks
    particleTracks=[]
    
    #Go over each z position
    for i in range(len(zArr)):
        
        print('Current z position- '+str(np.round(zArr[i],3))+'m')
            
        #Launch position
        xIni=np.array([0,0,zArr[i]])
        
        #Go over each theta angle
        for j in range(len(thetaArr)):
            
            #Go over each phi angle
            for k in range(len(phiArr)):
            
                #Single particle track
                stateVec=single_particle_track(xIni=xIni,energy=energy,theta=thetaArr[j],phi=phiArr[k],species=species)
                
                particleTracks.append(stateVec)
            
    #Convert to numpy
    particleTracks=np.array(particleTracks)
    
    #Generate the savename of the data
    #Get the name of the .nc file
    ncName=filename.split('/')[-1]
    #Remove the .nc part
    ncName=ncName[0:-3]
    savename=ncName+'_particleTracks.npy'
    #Save the data
    np.save(dataDest+savename,particleTracks)
    
    if makeplot==True:
        
        #Create the plot
        fig=plt.figure(figsize=(21,8))
        ax=fig.add_subplot(111)
        
        #Plot the poloidal flux
        #Plot limits
        psilim=eqDict['psi_lim']
        #Plot levels
        levels=np.linspace(0,psilim,40)
        
        pltobj=ax.contour(Zmesh,Rmesh,eqdsk_psi,levels=levels)
        pltobj=ax.contour(Zmesh,-Rmesh,eqdsk_psi,levels=levels)
        cbar=fig.colorbar(pltobj)
        cbar.set_label(r'$\Psi_B$ [$T \cdot m^2$]')
        
        #Number of particles
        numParticles=np.shape(particleTracks)[0]
        #Evenly spaced array for changing colors
        colorArr=np.linspace(0,1,numParticles)
        #Plot each ray
        for i in range(numParticles):
            ax.plot(particleTracks[i][2],particleTracks[i][1],color=(colorArr[i],0,0))
        
        ax.set_xlabel('Z [m]')
        ax.set_ylabel('X [m]')
        
        ax.set_xlim(np.min(Zmesh),np.max(Zmesh))
        ax.set_ylim(-np.max(Rmesh),np.max(Rmesh))
        
        ax.grid(True)
        
        if saveplot==True:
            
            #Generate the savename of the plot
            #Get the name of the .nc file
            ncName=filename.split('/')[-1]
            #Remove the .nc part
            ncName=ncName[0:-3]
            savename=ncName+'_fusion_particle_tracks.png'
            
            plt.savefig(plotDest+savename,bbox_inches='tight')
        
        plt.show()
    
    return particleTracks

def generate_tracks_cql3d(filename,species='H',makeplot=False,saveplot=False):
    """
    This function generates the fusion proton particle tracks for a given
    CQL3D output. The number of protons across z is scaled based on the
    fusion reactivity as a function of z from CQL3D.

    Parameters
    ----------
    filename : string
        Name of the CQL3D output file.
    species : string, optional
        Fusion product species. 
        The default is 'H'.
    makeplot : boolean, optional
        Make a plot of the data.
    saveplot : boolean, optional
        Save the plot.

    Returns
    -------
    particleTracks : np.array
        Data on the state vector for each fusion proton.
    """
    
    #Get the fusion neutron flux
    fusArr,zArr=cqlTools.axial_neutron_flux(filename)
    
    #Initial energy
    energy=3.02e6 #eV
    
    #Create an array that is weighted based on fusArr. This is done by changing how
    #many theta values there are per z position.
    
    #Max value of fusArr for normalization
    maxRxRate=np.max(fusArr)
    
    #Construct the theta array
    thetaArr=[]
    for i in range(len(zArr)):
        
        #Get the Rx rate at that point
        rxRate=fusArr[i]
        
        #Number of theta positions
        thetaPos=int((rxRate/maxRxRate)*100)
        
        thetaArr.append(np.linspace(0,2*np.pi,thetaPos))
        
    #Get the particle tracks
    particleTracks=[]
    
    #Go over each z position
    for i in range(len(zArr)):
        
        print('Current z position- '+str(np.round(zArr[i],3))+'m')
        
        #Go over each theta angle
        for j in range(len(thetaArr[i])):
            
            #Launch position
            xIni=np.array([0,0,zArr[i]])
            
            #Single particle track
            stateVec=single_particle_track(xIni=xIni,energy=energy,theta=thetaArr[i][j],species=species)
            
            particleTracks.append(stateVec)
            
    #Convert to numpy
    particleTracks=np.array(particleTracks)
    
    #Generate the savename of the data
    #Get the name of the .nc file
    ncName=filename.split('/')[-1]
    #Remove the .nc part
    ncName=ncName[0:-3]
    savename=ncName+'_particleTracks.npy'
    #Save the data
    np.save(dataDest+savename,particleTracks)
    
    if makeplot==True:
        
        #Create the plot
        fig=plt.figure(figsize=(21,8))
        ax=fig.add_subplot(111)
        
        #Plot the poloidal flux
        #Plot limits
        psilim=eqDict['psi_lim']
        #Plot levels
        levels=np.linspace(0,psilim,40)
        
        pltobj=ax.contour(Zmesh,Rmesh,eqdsk_psi,levels=levels)
        pltobj=ax.contour(Zmesh,-Rmesh,eqdsk_psi,levels=levels)
        cbar=fig.colorbar(pltobj)
        cbar.set_label(r'$\Psi_B$ [$T \cdot m^2$]')
        
        #Number of particles
        numParticles=np.shape(particleTracks)[0]
        #Evenly spaced array for changing colors
        colorArr=np.linspace(0,1,numParticles)
        #Plot each ray
        for i in range(numParticles):
            ax.plot(particleTracks[i][2],particleTracks[i][1],color=(colorArr[i],0,0))
        
        ax.set_xlabel('Z [m]')
        ax.set_ylabel('X [m]')
        
        ax.set_xlim(np.min(Zmesh),np.max(Zmesh))
        ax.set_ylim(-np.max(Rmesh),np.max(Rmesh))
        
        ax.grid(True)
        
        if saveplot==True:
            
            #Generate the savename of the plot
            #Get the name of the .nc file
            ncName=filename.split('/')[-1]
            #Remove the .nc part
            ncName=ncName[0:-3]
            savename=ncName+'_fusion_particle_tracks.png'
            
            plt.savefig(plotDest+savename,bbox_inches='tight')
        
        plt.show()
    
    return particleTracks

def on_segment(p,q,r):
    """
    This function checks if r lies on the line segment defined by (p,q).
    
    Code copied from- https://www.kite.com/python/answers/how-to-check-if-two-line-segments-intersect-in-python
    which is why inline comments are sparse.

    Parameters
    ----------
    p : list
        Format- [xVal,yVal]
        One end of the line segment.
    q : list
        Format- [xVal,yVal]
        Other end of the line segment.
    r : list
        Format- [xVal,yVal]
        Point which is being checked.

    Returns
    -------
    boolean whether r is on the line or not.
    """

    if r[0]<=max(p[0],q[0]) and r[0]>=min(p[0],q[0]) and r[1]<=max(p[1],q[1]) and r[1]>=min(p[1],q[1]):
        return True
    
    return False

def orientation(p,q,r):
    """
    This function checks the orientation of the 3 points p,q,r. Are they 
    clockwise, counterclockwise or colinear with respect to each other.
    
    Code copied from- https://www.kite.com/python/answers/how-to-check-if-two-line-segments-intersect-in-python
    which is why inline comments are sparse.

    Parameters
    ----------
    p : list
        Format- [xVal,yVal]
        Point 1.
    q : list
        Format- [xVal,yVal]
        Point 2.
    r : list
        Format- [xVal,yVal]
        Point 3.

    Returns
    -------
    int : 0 - colinear
          1 - clockwise
          2 - counterclockwise
    """

    val=((q[1]-p[1])*(r[0]-q[0]))-((q[0]-p[0])*(r[1]-q[1]))
    
    if val==0: 
        return 0
    
    return 1 if val>0 else -1

def line_intersection(seg1,seg2):
    """
    This function checks if 2 line segments intersect.
    
    Code copied from- https://www.kite.com/python/answers/how-to-check-if-two-line-segments-intersect-in-python
    which is why inline comments are sparse.

    Parameters
    ----------
    seg1 : list
        Format- [[x1,y1],[x2,y2]]
        Points defining line segment 1.
    seg2 : list
        Format- [[x1,y1],[x2,y2]]
        Points defining line segment 2.

    Returns
    -------
    boolean : True - seg1,seg2 intersect
              False- seg2,seg2 do not intersect
    """

    #Get the 4 points that define the line segments
    p1,q1=seg1
    p2,q2=seg2

    #Find all possible oprientations
    o1=orientation(p1,q1,p2)
    o2=orientation(p1,q1,q2)
    o3=orientation(p2,q2,p1)
    o4=orientation(p2,q2,q1)

    #Check the general case
    if o1!=o2 and o3!=o4:
        return True

    #Check the special cases
    if o1==0 and on_segment(p1,q1,p2) : return True
    if o2==0 and on_segment(p1,q1,q2) : return True
    if o3==0 and on_segment(p2,q2,p1) : return True
    if o4==0 and on_segment(p2,q2,q1) : return True

    return False

def line_plane_intersection(p0,p1,p_co,p_no,epsilon=1e-6):
    """
    This function checks if a line intersects a plane.
    
    The line is defined by 2 points- p0,p1.
    The plane is defined by a vector normal to the plane p_n0 and a point on
    the plane p_co.
    
    Code is copied from- https://stackoverflow.com/questions/5666222/3d-line-plane-intersection
    which is why inline comments are sparse.

    Parameters
    ----------
    p0 : np.array
        Format- [xVal,yVal,zVal]
        One point that defines the line.
    p1 : np.array
        Format- [xVal,yVal,zVal]
        Other point that defines the line.
    p_co : np.array
        Format- [xVal,yVal,zVal]
        Point on the plane.
    p_no : np.array
        Format- [xVal,yVal,zVal]
        Vector normal to the plane.
    epsilon : np.array, optional
        Limit for how || the line can be to the plane. 
        The default is 1e-6.

    Returns
    -------
    np.array : [x,y,z] point of intersection if the line intersects the plane.
               0 if the line is || to the plane
    """

    u=p1-p0
    dot=np.dot(p_no,u)

    if abs(dot)>epsilon:
        
        w=p0-p_co
        fac=-np.dot(p_no,w)/dot
        u=u*fac
        
        return p0+u

    #Line segment is || to the plane.
    return 0

def close_to_line(point,lp1,lp2,epsilon=1e-4):
    """
    This function checks if a point is close to a line segment defined by lp1
    and lp2.
    
    Code is copied from- http://www.fundza.com/vectors/point2line/index.html
    which is why inline comments are sparse.

    Parameters
    ----------
    point : np.array
        Point to be checked.
    lp1 : np.array
        One end of the line segment.
    lp2 : np.array
        Other end of the line segment.
    epsilon : np.array
        Closeness parameter.
        The default value is 1e-4

    Returns
    -------
    bool
        Whether the point is close to the line segment.
    """
    
    line_vec=lp1-lp2
    pnt_vec=lp1-point
    line_len=np.sqrt(line_vec.dot(line_vec))
    line_unitvec=line_vec/line_len
    pnt_vec_scaled=pnt_vec*(1/line_len)
    t=np.dot(line_unitvec,pnt_vec_scaled)
    
    if t<0:
        t=0
    elif t>1:
        t=1
    
    nearest=line_vec*t
    dist=np.sqrt((nearest-pnt_vec).dot(nearest-pnt_vec))
    nearest=nearest+lp1
    
    if dist<=epsilon:
        return True
    else:
        return False

def close_to_detector(point,detSize,detPos):
    """
    This function checks if the point of intersection as calculated by
    line_plane_intersection is close to the detector. i.e. is a valid hit on
    the neutron detector.

    Parameters
    ----------
    point : np.array
        Point to be checked for closeness to the detector.
    detSize : float
        Size of the detector in m^3. Assume circular shape.
    detPos : np.array
        Position of the center of the detector.
        Format- [x,y,z] in meters

    Returns
    -------
    bool
        Whether the point is close to the detector.
    """
    
    #Get the maximum allowable distance
    distLim=np.sqrt(detSize/np.pi)
    
    #Distance between the 2 points
    dist=np.sqrt((point-detPos).dot(point-detPos))
    
    if dist<=distLim:
        return True
    else:
        return False

def hit_vessel(point):
    """
    This function tests if the particle has hit the vessel wall.

    Parameters
    ----------
    point : np.array
        Current position of the particle.
        Format- [x,y,z] in meters

    Returns
    -------
    bool
        Whether the particle has hit the detector.
        True- Particle has hit the vessel wall.
        False- Particle has not hit the vessel wall.
    """
    
    #Radial position
    radPos=np.sqrt(point[0]**2+point[1]**2)
    
    #Radial boundary of the vessel
    if radPos>=0.37:
        return True
    #Axial boundary of the vessel
    if abs(point[2])>=1.44:
        return True
    
    #Base case
    return False

def correct_face(stateVec,detVec):
    """
    This function checks if the particle hits the correct face of the detector 
    when the particle track intersects with it.
    
    This is done by taking the dot product of the velocity with the area
    normal at the moment of interesection.
    
    If v dot A < 0 then it hit the correct surface

    Parameters
    ----------
    stateVec : np.array
        State vector of the particle at a given time.
        Format- [x,y,z,vx,vy,vz]
              - Postions in meters
              - Velocities in m/s
    detVec : np.array
        Vector normal to the detector surface.

    Returns
    -------
    bool
        Whether the particle hit the correct face of the detector.
        True- Particle hit the correct face
        False- Particle hit the wrong face.
    """
    
    #Get the velocity of the particle
    velocity=stateVec[3:]
    
    if np.dot(velocity,detVec)<0:
        return True
    else:
        return False

def single_particle_detector_hit(particleTrack,detectorLoc,detectorVec,detectorArea):
    """
    This function checks if the particle hits the detector.
    If there is a hit, it also returns the data on the particle track upto that
    point.

    Parameters
    ----------
    particleTrack : np.array
        State vector as a function of time (positions and velocities).
        Shape- particleTrack[0]=x(t)
               particleTrack[1]=y(t)
               particleTrack[2]=z(t)
               particleTrack[3]=vx(t)
               particleTrack[4]=vy(t)
               particleTrack[5]=vz(t)
    detectorLoc : np.array
        Position of the center of the detector.
        Format- [x,y,z] in meters
    detectorVec : np.array
        Vector normal to the detector surface.
    detectorArea : float
        Size of the detector in m^2

    Returns
    -------
    detectorHit : boolean
        Whether the particle hit the detector.
        True- Particle hit the detector
        False- Particle did not hit the detector
    contactTrack : np.array
        The state vector of the particle until it hit the particle.
        If the particle does not hit the detector, it returns an empty array
    """
    
    #Array to store particle track if it hits the detector
    contactTrack=[]
    
    #Store if the particle hits the detector
    detectorHit=False
    
    #Go over the current track
    for j in range(len(particleTrack[0])-1):
        
        #Position of the particle
        point1=particleTrack[0:3,j]
        
        #Check if the track hits the wall
        if hit_vessel(point1)==True:
            #No need to track if the particle hits the vessel
            break
        
        #Next point to define a line segment to test intersection
        point2=particleTrack[0:3,j+1]
        
        #Check if the line intersects the plane
        intPoint=line_plane_intersection(point1,point2,detectorLoc,detectorVec)
        if type(intPoint)==np.ndarray:
            
            #Check if the point of intersection is close to the track and detector
            onLine=close_to_line(intPoint,point1,point2)
            onDetector=close_to_detector(intPoint,detectorArea,detectorLoc)
            if onLine==True and onDetector==True:
                
                #Check if it hit the right face of the detector
                if correct_face(particleTrack[:,j],detectorVec)==True:
                    
                    #Change hit status
                    detectorHit=True
                
                    #Only add the part upto the hit
                    contactTrack=particleTrack[:,:j+1]
                
                    #No need to track further if the particle hits the detector
                    break
                
                #Stop tracking if it hits the wrong face
                else:
                    break
                
    #Convert to a numpy array
    contactTrack=np.array(contactTrack)
    
    return detectorHit,contactTrack

def multi_particle_detector_hit(particleTracks,detectorLoc,detectorVec,detectorArea):
    
    #Numpber of processing cores (let 4 be available for background tasks)
    ncores=os.cpu_count()-4
    
    #Run multithreaded analysis
    with Pool(ncores) as pool:
        
        contactTracks=pool.starmap(single_particle_detector_hit,    #Function to parallelize
                                   zip(particleTracks,              #Particle tracks
                                       repeat(detectorLoc),         #Detector location
                                       repeat(detectorVec),         #Detector normal
                                       repeat(detectorArea)))       #Detector area
    
    return contactTracks

def plot_particle_tracks(particleTracks,endpoints=True,startpoints=True,detectorLoc=0,detectorVec=0,detectorArea=0,make3d=False,saveplot=False):
    """
    This function plots a given set of particle tracks (defined in the variable
    'particleTracks') over a set of magnetic flux contours (defined in the 
    variable 'filenameEqdsk').
                                                            
    One can also plot the detector position and area vector by specifying the
    following variables-
    1. detectorLoc
    2. detectorVec
    3. detectorArea
    
    make3D allows you to plot the particle tracks and detector location in full
    3D.

    Parameters
    ----------
    particleTracks : np.array/list
        Particle track data.
    endpoints : boolean
        Scatterplot of the end points for the particle tracks.
    startpoints : boolean
        Scatterplot of the start points for the particle tracks.
    detectorLoc : np.array
        Location of the detector (center of the area element).
        Format- [x,y,z] in meters
        Default value is 0.
    detectorVec : np.array
        Vector normal to the detector surface.
        Default value is 0.
    detectorArea : float
        Area of the detector in m^2.
        Default value is 0.
    make3d : boolean
        Make a 3D plot of the particle tracks and detector position.
    saveplot : boolean
        Save the plot. Only works when make3d is 'False'

    Returns
    -------
    None.
    """
    
    #Make a 3D plot
    if make3d==True:
        
        #Initialize the plot
        fig=plt.figure()
        ax=plt.axes(projection='3d')
        
        #Plot each ray
        for i in range(len(particleTracks)):
            
            ax.plot3D(particleTracks[i][0],particleTracks[i][1],particleTracks[i][2],color='red')
            
            #Plot the endpoints
            if endpoints==True:
                #Only add label to 1 track
                if i==1:
                    ax.scatter3D(particleTracks[i][0][-1],particleTracks[i][1][-1],particleTracks[i][2][-1],zorder=5,color='blue',label='End Point')
                else:
                    ax.scatter3D(particleTracks[i][0][-1],particleTracks[i][1][-1],particleTracks[i][2][-1],zorder=5,color='blue')
                    
        #Plot the detector
        if type(detectorLoc)!=int:
            
            #Detector normal
            ax.quiver(detectorLoc[0],detectorLoc[1],detectorLoc[2],detectorVec[0],detectorVec[1],detectorVec[2],pivot='tail',length=0.05,zorder=10)
            
            #Detector boundary
            #100 points on a unit circle in the xy-plane
            detPosArr=np.array([np.cos(np.linspace(0,2*np.pi,100)),np.sin(np.linspace(0,2*np.pi,100)),np.zeros(100)])
            #Scale unit circle to detector size
            detPosArr*=np.sqrt(detectorArea/np.pi)
            #Angles by which to rotate this circle based on the detector normal
            theta=np.arccos(detectorVec[2])
            phi=np.arccos(detectorVec[0]/np.sin(theta))
            #Initialize the rotation
            rotObj=R.from_euler('ZYX',[phi,theta,0])
            #Apply the rotation to each point
            rotArr=[]
            for i in range(len(detPosArr[0])):
                rotArr.append(rotObj.apply(detPosArr[:,i]))
            rotArr=np.array(rotArr)
            #Move to the detector location
            rotArr+=detectorLoc
            #Plot the detector boundary
            ax.plot3D(rotArr[:,0],rotArr[:,1],rotArr[:,2],label='Detector')
            
        ax.set_xlabel('X [m]')
        ax.set_ylabel('Y [m]')
        ax.set_zlabel('Z [m]')
        
        ax.set_xlim(np.min(Rmesh),np.max(Rmesh))
        ax.set_ylim(-np.max(Rmesh),np.max(Rmesh))
        ax.set_zlim(np.min(Zmesh),np.max(Zmesh))
        
        ax.legend()
        ax.grid(True)
        
        plt.show()
        
    #Make a 2D plot
    else:
        
        #Create the plot
        fig=plt.figure(figsize=(21,8))
        ax=fig.add_subplot(111)
        
        #Plot the poloidal flux
        #Plot limits
        psilim=eqDict['psi_lim']
        #Plot levels
        levels=np.linspace(0,psilim,40)
        
        pltobj=ax.contour(Zmesh,Rmesh,eqdsk_psi,levels=levels)
        pltobj=ax.contour(Zmesh,-Rmesh,eqdsk_psi,levels=levels)
        cbar=fig.colorbar(pltobj)
        cbar.set_label(r'$\Psi_B$ [$T \cdot m^2$]')
        
        #Plot each ray
        for i in range(len(particleTracks)):
            
            ax.plot(particleTracks[i][2],particleTracks[i][0],color='red')
        
            #Plot the endpoints
            if endpoints==True:
                #Only add label to 1 track
                if i==1:
                    ax.scatter(particleTracks[i][2][-1],particleTracks[i][0][-1],zorder=5,color='blue',label='End Point')
                else:
                    ax.scatter(particleTracks[i][2][-1],particleTracks[i][0][-1],zorder=5,color='blue')
            #Plot the startpoints
            if startpoints==True:
                #Only add label to 1 track
                if i==1:
                    ax.scatter(particleTracks[i][2][0],particleTracks[i][0][0],s=75,zorder=5,color='black',label='Start Point')
                else:
                    ax.scatter(particleTracks[i][2][0],particleTracks[i][0][0],s=75,zorder=5,color='black')
        
        #Plot the detector
        if type(detectorLoc)!=int:
            
            #Detector normal
            ax.quiver(detectorLoc[2],detectorLoc[0],detectorVec[2],detectorVec[0],width=3e-3,zorder=10)
            # ax.quiverkey(detNormalObj,0.9,0.9,1,label='Detector Normal',labelpos='E')
            
            #Detector boundary
            #100 points on a unit circle in the xy-plane
            detPosArr=np.array([np.cos(np.linspace(0,2*np.pi,100)),np.sin(np.linspace(0,2*np.pi,100)),np.zeros(100)])
            #Scale unit circle to detector size
            detPosArr*=np.sqrt(detectorArea/np.pi)
            #Angles by which to rotate this circle based on the detector normal
            theta=np.arccos(detectorVec[2])
            phi=np.arccos(detectorVec[0]/np.sin(theta))
            #Initialize the rotation
            rotObj=R.from_euler('ZYX',[phi,theta,0])
            #Apply the rotation to each point
            rotArr=[]
            for i in range(len(detPosArr[0])):
                rotArr.append(rotObj.apply(detPosArr[:,i]))
            rotArr=np.array(rotArr)
            #Move to the detector location
            rotArr+=detectorLoc
            #Plot the detector boundary
            ax.plot(rotArr[:,2],rotArr[:,0],label='Detector')
        
        ax.set_xlabel('Z [m]')
        ax.set_ylabel('X [m]')
        
        ax.set_xlim(np.min(Zmesh),np.max(Zmesh))
        ax.set_ylim(-np.max(Rmesh),np.max(Rmesh))
        
        ax.legend()
        ax.grid(True)
        
        if saveplot==True:
                
                #Generate the savename of the plot
                #Get the name of the .nc file
                ncName=filename.split('/')[-1]
                #Remove the .nc part
                ncName=ncName[0:-3]
                savename=ncName+'_fusion_particle_tracks.png'
                
                plt.savefig(plotDest+savename,bbox_inches='tight')
        
        plt.show()
    
    return

#%% Proton detector placement analysis

#Location of the CQL3D output
filename='C:/Users/kunal/OneDrive - UW-Madison/WHAM/Data/CQL3D/WHAM_phase2_1NBI_250kW_rf_20211105jka_narrowgrill_th81.nc'

#Scale output to cql3d data
scaleOutput=False

#Detector parameters

#Position
detPos=np.array([0.15,0,0.2]) #meters

#Orientation
#Theta (angle wrt z axis) (0 is radially outwards in cylindrical coordinates)
detTheta=np.pi #radians
#Phi (angle wrt x axis)
detPhi=np.pi/2 #radians

#Size
detSize=5000*1e-6 #m^2

#Normal vector of the detector
detNorm=np.array([np.cos(detTheta)*np.sin(detPhi),np.cos(detTheta)*np.cos(detPhi),np.sin(detTheta)])

#Particle species
species='H'

#eqdsk data object
eqDict=eqTools.read_eqdsk(filenameEqdsk)

#Flux surface data
Rmesh,Zmesh,eqdsk_psi=eqTools.flux_surfaces(filenameEqdsk)

#Get the particle tracks
particleTracks=[]

if scaleOutput==True:
    
    #Get the name of the cql3d .nc file
    ncName=filename.split('/')[-1]
    #Remove the .nc part
    ncName=ncName[0:-3]
    savename=ncName+'_particleTracks.npy'
    #Load the data
    try:
        particleTracks=np.load('C:/Users/kunal/OneDrive - UW-Madison/WHAM/Data/'+savename)
    except:
        particleTracks=generate_tracks_cql3d(filename,species=species)

else:
    #Get the name of the eqdsk .nc file
    ncName=filenameEqdsk.split('/')[-1]
    #Remove the .nc part
    ncName=ncName[0:-3]
    savename=ncName+'_particleTracks.npy'
    #Load the data
    try:
        particleTracks=np.load('C:/Users/kunal/OneDrive - UW-Madison/WHAM/Data/'+savename)
    except:
        particleTracks=generate_tracks_eqdsk(filenameEqdsk,species=species)
        
#Convert to numpy
particleTracks=np.array(particleTracks)

#Plot all the particles
# plot_particle_tracks(particleTracks)

#Perform the detection analysis
contactTracks=multi_particle_detector_hit(particleTracks,detPos,detNorm,detSize)

#%% Plot the analysis

plot_particle_tracks(contactTracks,endpoints=True,startpoints=True,detectorLoc=detPos,detectorVec=detNorm,detectorArea=detSize,make3d=False)

#%% Debugging

plot_particle_tracks([particleTracks[2433]],endpoints=True,startpoints=False,detectorLoc=detPos,detectorVec=detNorm,detectorArea=detSize)

#Get the current track
currTrack=particleTracks[2433]

#Go over the current track
for j in range(len(currTrack[0])-1):
    
    #Get the 2 points that define a line segment
    point1=currTrack[0:3,j]
    point2=currTrack[0:3,j+1]
    
    radPos=np.sqrt(point1[0]**2+point1[1]**2)
    
    print(point1)
    
    print('Radial Position- '+str(radPos))
    
    #Check if the track hits the wall
    if hit_vessel(point1)==True:
        
        print('Hit wall')

#%% Multiple particles, multiple launch points

#Particle species
species='H'

#Number of z positions
zPos=10
#Number of theta positions
thetaPos=15

#Initial positions
xIniArr=np.transpose([np.zeros(zPos),np.zeros(zPos),np.linspace(-0.75,0.75,zPos)])

#Initial energy and angles
energy=3.02e6 #eV
thetaArr=np.linspace(0,2*np.pi,thetaPos)

#eqdsk data object
eqDict=eqTools.read_eqdsk(filenameEqdsk)

#Flux surface data
Rmesh,Zmesh,eqdsk_psi=eqTools.flux_surfaces(filenameEqdsk)

#Get the particle tracks
particleTracks=[]
#Go over each launch position
for i in range(zPos):
    #Go over each theta angle
    for j in range(thetaPos):
        
        #Single particle track
        stateVec=single_particle_track(xIni=xIniArr[i],energy=energy,theta=thetaArr[j])
        #Add track to the array
        particleTracks.append(stateVec)
    
#Convert to numpy
particleTracks=np.array(particleTracks)

#Create the plot
fig=plt.figure(figsize=(21,8))
ax=fig.add_subplot(111)

#Plot the poloidal flux
#Plot limits
psilim=eqDict['psi_lim']
#Plot levels
levels=np.linspace(0,psilim,40)

pltobj=ax.contour(Zmesh,Rmesh,eqdsk_psi,levels=levels)
pltobj=ax.contour(Zmesh,-Rmesh,eqdsk_psi,levels=levels)
cbar=fig.colorbar(pltobj)
cbar.set_label(r'$\Psi_B$ [$T \cdot m^2$]')

#Number of particles
numParticles=np.shape(particleTracks)[0]
#Evenly spaced array for chaning colors
colorArr=np.linspace(0,1,numParticles)
#Plot each ray
for i in range(numParticles):
    ax.plot(particleTracks[i][2],particleTracks[i][1],color=(colorArr[i],0,0))

ax.set_xlabel('Z [m]')
ax.set_ylabel('X [m]')

ax.set_xlim(np.min(Zmesh),np.max(Zmesh))
ax.set_ylim(-np.max(Rmesh),np.max(Rmesh))

ax.grid(True)

plt.show()

#%% Multiple particles, single launch point

#Particle species
species='H'

#Initial position
xIni=[0,0,0.58]

#Initial energy and angles
energy=3.02e6 #eV
thetaArr=np.linspace(0,2*np.pi,50)

#eqdsk data object
eqDict=eqTools.read_eqdsk(filenameEqdsk)

#Flux surface data
Rmesh,Zmesh,eqdsk_psi=eqTools.flux_surfaces(filenameEqdsk)

#Get the particle tracks
particleTracks=[]
for i in range(len(thetaArr)):
    
    #Single particle track
    stateVec=single_particle_track(xIni=xIni,energy=energy,theta=thetaArr[i])
    
    particleTracks.append(stateVec)
    
#Convert to numpy
particleTracks=np.array(particleTracks)

#Create the plot
fig=plt.figure(figsize=(21,8))
ax=fig.add_subplot(111)

#Plot the poloidal flux
#Plot limits
psilim=eqDict['psi_lim']
#Plot levels
levels=np.linspace(0,psilim,40)

pltobj=ax.contour(Zmesh,Rmesh,eqdsk_psi,levels=levels)
pltobj=ax.contour(Zmesh,-Rmesh,eqdsk_psi,levels=levels)
cbar=fig.colorbar(pltobj)
cbar.set_label(r'$\Psi_B$ [$T \cdot m^2$]')

#Number of particles
numParticles=np.shape(particleTracks)[0]
#Evenly spaced array for chaning colors
colorArr=np.linspace(0,1,numParticles)
#Plot each ray
for i in range(numParticles):
    ax.plot(particleTracks[i][2],particleTracks[i][1],color=(colorArr[i],0,0))

ax.set_xlabel('Z [m]')
ax.set_ylabel('X [m]')

ax.set_xlim(np.min(Zmesh),np.max(Zmesh))
ax.set_ylim(-np.max(Rmesh),np.max(Rmesh))

ax.grid(True)

plt.show()

#%% Single particle test

#Particle species
species='H'

#Initial position
xIni=[0,0,0.58]

#Initial energy and angles
energy=3.02e6 #eV
theta=np.pi/4

#eqdsk data object
eqDict=eqTools.read_eqdsk(filenameEqdsk)

#Flux surface data
Rmesh,Zmesh,eqdsk_psi=eqTools.flux_surfaces(filenameEqdsk)

#Get the particle track
stateVec=single_particle_track(xIni=xIni,energy=energy,theta=theta)

#Create the plot
fig=plt.figure(figsize=(21,8))
ax=fig.add_subplot(111)

#Plot the poloidal flux
#Plot limits
psilim=eqDict['psi_lim']
#Plot levels
levels=np.linspace(0,psilim,40)

pltobj=ax.contour(Zmesh,Rmesh,eqdsk_psi,levels=levels)
pltobj=ax.contour(Zmesh,-Rmesh,eqdsk_psi,levels=levels)
cbar=fig.colorbar(pltobj)
cbar.set_label(r'$\Psi_B$ [$T \cdot m^2$]')

ax.plot(stateVec[2],stateVec[1],label='Particle Track')

ax.set_xlabel('Z [m]')
ax.set_ylabel('X [m]')

ax.grid(True)
ax.legend()

plt.show()