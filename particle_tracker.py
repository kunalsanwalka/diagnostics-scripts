# -*- coding: utf-8 -*-
"""
Created on Tue Nov 23 10:23:42 2021

@author: kunal

This program tracks the position of the particle through a magnetic field.

The magnetic field data is pulled from an eqdsk generated by pleiades.
"""

import sys
sys.path.insert(1,'C:/Users/kunal/OneDrive - UW-Madison/WHAM/Python Scripts/')

import random
import numpy as np
import scipy.constants as const
import matplotlib.pyplot as plt
import eqdsk_analysis_toolbox as eqTools
import cql3d_analysis_functions as cqlTools
from scipy.interpolate import RegularGridInterpolator
from scipy.integrate import solve_ivp
from scipy.spatial.transform import Rotation as R
from random_geometry_points.plane import Plane

# =============================================================================
# Plot Directory
# =============================================================================
plotDest='C:/Users/kunal/OneDrive - UW-Madison/WHAM/Plots/'

# =============================================================================
# Data Directory
# =============================================================================
dataDest='C:/Users/kunal/OneDrive - UW-Madison/WHAM/Data/'

# =============================================================================
# Magnetic field data location
# =============================================================================
filenameEqdsk='C:/Users/kunal/OneDrive - UW-Madison/WHAM/Data/eqdsk/WHAM_Phase_2_eqdsk'

# =============================================================================
# Field interpolation functions
# =============================================================================

#Field values
Rmesh,Zmesh,Br,Bz,Bmag=eqTools.magnetic_field_RZ(filenameEqdsk)

#Interpolation function for magnetic field data
#Converts the grid data into a function which can return Br and Bz at any
#given (r,z)
global BzInterpolator,BrInterpolator,BmagInterpolator
BzInterpolator=RegularGridInterpolator((Zmesh[:,0],Rmesh[0]),Bz)
BrInterpolator=RegularGridInterpolator((Zmesh[:,0],Rmesh[0]),Br)
BmagInterpolator=RegularGridInterpolator((Zmesh[:,0],Rmesh[0]),Bmag)

def charge_to_mass_ratio(species):
    """
    This function calculates the charge to mass ratio for a given species.
    
    Available Species (Code)
    1.  Hydrogen (H)
    2.  Deuterium (D)
    3.  Tritium (T)
    4.  Helium-3 (He3)
    5.  Helium-4 (He4)
    6.  TR Hydrogen (tH)
    7.  TR Deuterium (tD)
    8.  TR Tritium (tT)
    9.  TR Helium-3 (tHe3)
    10. TR Helium-4 (tHe4)
    
    The ones labelled as time reveral (TR) have the opposite charge. This is so
    we can track their orbits backwards in time while using the same
    integrating functions.

    Parameters
    ----------
    species : string
        Species code.

    Returns
    -------
    qm : float
        Charge to mass ratio (C/kg).
    """
    
    #Initialize
    qm=0
    
    if species=='H':
        qm=const.e/const.m_p
    elif species=='D':
        qm=const.e/(const.m_n+const.m_p)
    elif species=='T':
        qm=const.e/(2*const.m_n+const.m_p)
    elif species=='He3':
        qm=2*const.e/(const.m_n+2*const.m_p)
    elif species=='He4':
        qm=2*const.e/(2*const.m_n+2*const.m_p)
    elif species=='tH':
        qm=-const.e/const.m_p
    elif species=='tD':
        qm=-const.e/(const.m_n+const.m_p)
    elif species=='tT':
        qm=-const.e/(2*const.m_n+const.m_p)
    elif species=='tHe3':
        qm=-2*const.e/(const.m_n+2*const.m_p)
    elif species=='tHe4':
        qm=-2*const.e/(2*const.m_n+2*const.m_p)
    
    return qm

def particle_mass(species):
    """
    This function calculates the mass of the particle for a given species.
    
    Available Species (Code)
    1.  Hydrogen (H)
    2.  Deuterium (D)
    3.  Tritium (T)
    4.  Helium-3 (He3)
    5.  Helium-4 (He4)
    6.  TR Hydrogen (tH)
    7.  TR Deuterium (tD)
    8.  TR Tritium (tT)
    9.  TR Helium-3 (tHe3)
    10. TR Helium-4 (tHe4)
    
    The ones labelled at time reversal (TR) are used for orbit tracking
    backwards in time. The mass does not change in this case.

    Parameters
    ----------
    species : string
        Species code.

    Returns
    -------
    m : float
        Mass of the species (in kg).
    """
    
    #Initalize
    m=0
    
    if species=='H' or species=='tH':
        m=const.m_p
    elif species=='D' or species=='tD':
        m=const.m_n+const.m_p
    elif species=='T' or species=='tT':
        m=2*const.m_n+const.m_p
    elif species=='He3' or species=='tHe3':
        m=const.m_n+2*const.m_p
    elif species=='He4' or species=='tHe4':
        m=2*const.m_n+2*const.m_p
    
    return m

def fusion_energy(species):
    """
    This function calculates the energy of the fusion product.
    
    H,T and He3 assume they are products of DD fusion.
    He4 assume it is a product of DT fusion.
    
    Available Species (Code)
    1.  Hydrogen (H)
    2.  Tritium (T)
    3.  Helium-3 (He3)
    4.  Helium-4 (He4)
    5.  TR Hydrogen (tH)
    6.  TR Tritium (tT)
    7.  TR Helium-3 (tHe3)
    8.  TR Helium-4 (tHe4)
    
    The ones labelled at time reversal (TR) are used for orbit tracking
    backwards in time. The energy does not change in this case.
    
    All values are taken from- https://en.wikipedia.org/wiki/Nuclear_fusion

    Parameters
    ----------
    species : string
        Species code.

    Returns
    -------
    energy : float
        Energy of the species (in eV).
    """
    
    #Initalize
    energy=0
    
    if species=='H' or species=='tH':
        energy=3.02e6
    elif species=='T' or species=='tT':
        energy=1.01e6
    elif species=='He3' or species=='tHe3':
        energy=0.82e6
    elif species=='He4' or species=='tHe4':
        energy=3.52e6
    
    return energy

def initialize_particle(energy,theta,phi=0,species='D'):
    """
    This function converts energy and the angles to the cartesian components
    of the velocity vector.

    Parameters
    ----------
    energy : float
        Energy of the particle (eV).
    theta : float
        Angle with the z-axis (radians).
    phi : float, optional
        Angle with the x-axis (radians).
        The default is 0.
    species : string, optional
        Species code. 
        The default is 'D'.

    Returns
    -------
    velArr : np.array
        Initial velocty of the particle in cartesian coordinates (m/s).
    """
    
    #Convert energy to Joules
    eJ=energy*const.e
    
    #Mass of the particle
    m=particle_mass(species)
        
    #Magnitude of the velocity
    velMag=np.sqrt(2*eJ/m)
    
    #Cartesian conponents of each velocity
    vx=velMag*np.sin(theta)*np.cos(phi)
    vy=velMag*np.sin(theta)*np.sin(phi)
    vz=velMag*np.cos(theta)
    
    velArr=np.array([vx,vy,vz])
    
    return velArr

def integrand(t,y,species='D'):
    """
    This function is the integrand used by the solve_ivp function called in
    single_particle_track. This is done as scipy already has a built in initial
    value problem integrator which is more accurate than anything I can write.

    Parameters
    ----------
    t : float
        Time (s).
    y : np.array
        State vector (positions and velocities).
        Shape- y[0]=x
               y[1]=y
               y[2]=z
               y[3]=vx
               y[4]=vy
               y[5]=vz
    species : string, optional
        Species code. 
        The default is 'D'.

    Returns
    -------
    dvdt : np.array
        dy/dt (velocity and acceleration).
        Shape- dvdt[0]=vx
               dvdt[1]=vy
               dvdt[2]=vz
               dvdt[3]=ax
               dvdt[4]=ay
               dvdt[5]=az
    """
    
    #Positions
    xPos=y[0]
    yPos=y[1]
    zPos=y[2]
    
    #Velocities
    vx=y[3]
    vy=y[4]
    vz=y[5]
    
    #Convert x,y to cylindrical
    r=np.sqrt(xPos**2+yPos**2)
    theta=np.arctan2(yPos,xPos)
    
    #Try-except block since the particle can go beyond the range of the
    #generated eqdsk. If this were to happen to a real particle it would have
    #hit the wall anyway so just set v and a to 0.
    try:
        #Get Br and Bz at those points
        Br=BrInterpolator([zPos,r])[0]
        Bz=BzInterpolator([zPos,r])[0]
        
    except ValueError:
        Br=0
        Bz=0
        vx=0
        vy=0
        vz=0
    
    #Convert Br to Bx and By
    Bx=Br*np.cos(theta)
    By=Br*np.sin(theta)
    
    #Charge to mass ratio
    qm=charge_to_mass_ratio(species)
    
    #Calculate acceleration
    dvdt=[vx,               #vx
          vy,               #vy
          vz,               #vz
          qm*(vy*Bz-vz*By), #ax
          qm*(vz*Bx-vx*Bz), #ay
          qm*(vx*By-vy*Bx)] #az
    
    return dvdt

def integrand_relativistic(t,y,species='D'):
    """
    This function is the integrand used by the solve_ivp function called in
    single_particle_track. This is done as scipy already has a built in initial
    value problem integrator which is more accurate than anything I can write.

    Parameters
    ----------
    t : float
        Time (s).
    y : np.array
        State vector (positions and velocities).
        Shape- y[0]=x
               y[1]=y
               y[2]=z
               y[3]=vx
               y[4]=vy
               y[5]=vz
    species : string, optional
        Species code. 
        The default is 'D'.

    Returns
    -------
    dvdt : np.array
        dy/dt (velocity and acceleration).
        Shape- dvdt[0]=vx
               dvdt[1]=vy
               dvdt[2]=vz
               dvdt[3]=ax
               dvdt[4]=ay
               dvdt[5]=az
    """
    
    #Positions
    xPos=y[0]
    yPos=y[1]
    zPos=y[2]
    
    #Velocities
    vx=y[3]
    vy=y[4]
    vz=y[5]
    
    #Convert x,y to cylindrical
    r=np.sqrt(xPos**2+yPos**2)
    theta=np.arctan2(yPos,xPos)
    
    #Try-except block since the particle can go beyond the range of the
    #generated eqdsk. If this were to happen to a real particle it would have
    #hit the wall anyway so just set v and a to 0.
    try:
        #Get Br and Bz at those points
        Br=BrInterpolator([zPos,r])[0]
        Bz=BzInterpolator([zPos,r])[0]
        
    except ValueError:
        Br=0
        Bz=0
        vx=0
        vy=0
        vz=0
    
    #Convert Br to Bx and By
    Bx=Br*np.cos(theta)
    By=Br*np.sin(theta)
    
    #Charge to mass ratio
    qm=charge_to_mass_ratio(species)
    
    #Gamma factor
    gamma=1/np.sqrt(1-((vx**2+vy**2+vz**2)/const.c**2))
    
    #Calculate acceleration
    dvdt=[vx,                       #vx
          vy,                       #vy
          vz,                       #vz
          gamma*qm*(vy*Bz-vz*By),   #ax
          gamma*qm*(vz*Bx-vx*Bz),   #ay
          gamma*qm*(vx*By-vy*Bx)]   #az
    
    return dvdt

def single_particle_track(xIni,energy,theta,phi=0,species='H'):
    """
    This function tracks the motion of the particle through the magnetic field
    as a function of the inital position and velocity.
    
    This is done with the help of the solve_ivp function from scipy. It is used
    to solve an initial value problem for ODE's. The exact syntax of it is
    complicated but it seems to be a 1 line affair. solve_ivp solves
    differential equations of the form-
    dy/dt=f(y,t)
    
    Orbit tracking is done by solving the Lorentz force equation in a magnetic
    field-
    a=(q/m)*(v x B)
    
    solve_ivp takes the Lorentz force equation written with velocities-
    vdot=(q/m)*(v x B)
    
    This along with the initial position and velocity (inferred from the 
    energy, theta and phi) gives the value of the state vector (position and 
    velocity) at all times.

    Parameters
    ----------
    xIni : np.array
        Initial position of the particle.
        Shape- xIni=[x0,y0,z0]
    energy : float
        Energy of the particle (eV).
    theta : float
        Angle with the z-axis (radians).
    phi : float, optional
        Angle with the x-axis (radians).
        The default is 0.
    species : string, optional
        Species code. 
        The default is 'H'.

    Returns
    -------
    stateVec : np.array
        State vector as a function of time (positions and velocities).
        Shape- posArr[0]=x(t)
               posArr[1]=y(t)
               posArr[2]=z(t)
               posArr[3]=vx(t)
               posArr[4]=vy(t)
               posArr[5]=vz(t)
    """
    
    #Number of timesteps
    timesteps=10000
    
    #Length of each timestep
    steplength=1e-9 #seconds
    
    #Total time for the integration
    totTime=timesteps*steplength
    
    #Get the initial velocity of the particle in cartesian coordinates
    vIni=initialize_particle(energy,theta,phi=phi,species=species)
    
    #Initial conditions array
    initCond=np.concatenate((xIni,vIni))
    
    #Solve the inital value problem for the position and velocity
    stateVec=solve_ivp(fun=integrand_relativistic,              #f(y,t)
                       t_span=(0,totTime),                      #Time domain over which we want the solution
                       y0=initCond,                             #Initial conditions
                       t_eval=np.linspace(0,totTime,timesteps), #Timesteps at which to save the state vector
                       args=(species,))                         #Other arguments in 'integrand'
    
    return stateVec.y

def generate_tracks_eqdsk(filename,species='H',makeplot=False,saveplot=False):
    """
    This function generates the fusion proton particle tracks for a given
    eqdsk output. The number of protons across z is uniform.

    Parameters
    ----------
    filename : string
        Name of the eqdsk output file.
    species : string, optional
        Fusion product species. 
        The default is 'H'.
    makeplot : boolean, optional
        Make a plot of the data.
    saveplot : boolean, optional
        Save the plot.

    Returns
    -------
    particleTracks : np.array
        Data on the state vector for each fusion proton.
    """
    
    #Initial energy
    energy=fusion_energy(species)
    
    #eqdsk mesh arrays
    Rmesh,Zmesh,eqdsk_psi=eqTools.flux_surfaces(filename=filename)
    
    #z limits
    zMax=np.max(Zmesh)
    zMin=np.min(Zmesh)
    
    #z array
    zArr=np.linspace(zMin,zMax,100)
    
    #Construct the theta array
    thetaArr=np.linspace(0,2*np.pi,10)
    
    #Construct the phi array
    phiArr=np.linspace(0,np.pi,10)
    
    #Get the particle tracks
    particleTracks=[]
    
    #Go over each z position
    for i in range(len(zArr)):
        
        print('Current z position- '+str(np.round(zArr[i],3))+'m')
            
        #Launch position
        xIni=np.array([0,0,zArr[i]])
        
        #Go over each theta angle
        for j in range(len(thetaArr)):
            
            #Go over each phi angle
            for k in range(len(phiArr)):
            
                #Single particle track
                stateVec=single_particle_track(xIni=xIni,energy=energy,theta=thetaArr[j],phi=phiArr[k],species=species)
                
                particleTracks.append(stateVec)
            
    #Convert to numpy
    particleTracks=np.array(particleTracks)
    
    #Generate the savename of the data
    #Get the name of the .nc file
    ncName=filename.split('/')[-1]
    #Remove the .nc part
    ncName=ncName[0:-3]
    savename=ncName+'_particleTracks.npy'
    #Save the data
    np.save(dataDest+savename,particleTracks)
    
    if makeplot==True:
        
        #Create the plot
        fig=plt.figure(figsize=(21,8))
        ax=fig.add_subplot(111)
        
        #Plot the poloidal flux
        #Plot limits
        psilim=eqDict['psi_lim']
        #Plot levels
        levels=np.linspace(0,psilim,40)
        
        pltobj=ax.contour(Zmesh,Rmesh,eqdsk_psi,levels=levels)
        pltobj=ax.contour(Zmesh,-Rmesh,eqdsk_psi,levels=levels)
        cbar=fig.colorbar(pltobj)
        cbar.set_label(r'$\Psi_B$ [$T \cdot m^2$]')
        
        #Number of particles
        numParticles=np.shape(particleTracks)[0]
        #Evenly spaced array for changing colors
        colorArr=np.linspace(0,1,numParticles)
        #Plot each ray
        for i in range(numParticles):
            ax.plot(particleTracks[i][2],particleTracks[i][1],color=(colorArr[i],0,0))
        
        ax.set_xlabel('Z [m]')
        ax.set_ylabel('X [m]')
        
        ax.set_xlim(np.min(Zmesh),np.max(Zmesh))
        ax.set_ylim(-np.max(Rmesh),np.max(Rmesh))
        
        ax.grid(True)
        
        if saveplot==True:
            
            #Generate the savename of the plot
            #Get the name of the .nc file
            ncName=filename.split('/')[-1]
            #Remove the .nc part
            ncName=ncName[0:-3]
            savename=ncName+'_fusion_particle_tracks.png'
            
            plt.savefig(plotDest+savename,bbox_inches='tight')
        
        plt.show()
    
    return particleTracks

def generate_tracks_cql3d_old(filename,species='H',makeplot=False,saveplot=False):
    """
    This function generates the fusion proton particle tracks for a given
    CQL3D output. The number of protons across z is scaled based on the
    fusion reactivity as a function of z from CQL3D.
    
    NOTE- This function does not sample the phase space of initial launch
          angles randomly and therefore, can be biased

    Parameters
    ----------
    filename : string
        Name of the CQL3D output file.
    species : string, optional
        Fusion product species. 
        The default is 'H'.
    makeplot : boolean, optional
        Make a plot of the data.
    saveplot : boolean, optional
        Save the plot.

    Returns
    -------
    particleTracks : np.array
        Data on the state vector for each fusion proton.
    """
    
    #Get the axial fusion neutron flux
    fusArr,zArr=cqlTools.axial_neutron_flux(filename)
    
    #Initial energy
    energy=fusion_energy(species)
    
    #Create an array that is weighted based on fusArr. This is done by changing how
    #many theta values there are per z position.
    
    #Max value of fusArr for normalization
    maxRxRate=np.max(fusArr)
    
    #Construct the theta array
    thetaArr=[]
    for i in range(len(zArr)):
        
        #Get the Rx rate at that point
        rxRate=fusArr[i]
        
        #Number of theta positions
        thetaPos=int((rxRate/maxRxRate)*100)
        
        thetaArr.append(np.linspace(0,2*np.pi,thetaPos))
        
    #Get the particle tracks
    particleTracks=[]
    
    #Go over each z position
    for i in range(len(zArr)):
        
        print('Current z position- '+str(np.round(zArr[i],3))+'m')
        
        #Go over each theta angle
        for j in range(len(thetaArr[i])):
            
            #Launch position
            xIni=np.array([0,0,zArr[i]])
            
            #Single particle track
            stateVec=single_particle_track(xIni=xIni,energy=energy,theta=thetaArr[i][j],species=species)
            
            particleTracks.append(stateVec)
            
    #Convert to numpy
    particleTracks=np.array(particleTracks)
    
    #Generate the savename of the data
    #Get the name of the .nc file
    ncName=filename.split('/')[-1]
    #Remove the .nc part
    ncName=ncName[0:-3]
    savename=ncName+'_particleTracks.npy'
    #Save the data
    np.save(dataDest+savename,particleTracks)
    
    if makeplot==True:
        
        #Create the plot
        fig=plt.figure(figsize=(21,8))
        ax=fig.add_subplot(111)
        
        #Plot the poloidal flux
        #Plot limits
        psilim=eqDict['psi_lim']
        #Plot levels
        levels=np.linspace(0,psilim,40)
        
        pltobj=ax.contour(Zmesh,Rmesh,eqdsk_psi,levels=levels)
        pltobj=ax.contour(Zmesh,-Rmesh,eqdsk_psi,levels=levels)
        cbar=fig.colorbar(pltobj)
        cbar.set_label(r'$\Psi_B$ [$T \cdot m^2$]')
        
        #Number of particles
        numParticles=np.shape(particleTracks)[0]
        #Evenly spaced array for changing colors
        colorArr=np.linspace(0,1,numParticles)
        #Plot each ray
        for i in range(numParticles):
            ax.plot(particleTracks[i][2],particleTracks[i][1],color=(colorArr[i],0,0))
        
        ax.set_xlabel('Z [m]')
        ax.set_ylabel('X [m]')
        
        ax.set_xlim(np.min(Zmesh),np.max(Zmesh))
        ax.set_ylim(-np.max(Rmesh),np.max(Rmesh))
        
        ax.grid(True)
        
        if saveplot==True:
            
            #Generate the savename of the plot
            #Get the name of the .nc file
            ncName=filename.split('/')[-1]
            #Remove the .nc part
            ncName=ncName[0:-3]
            savename=ncName+'_fusion_particle_tracks.png'
            
            plt.savefig(plotDest+savename,bbox_inches='tight')
        
        plt.show()
    
    return particleTracks

def generate_tracks_cql3d(filename,species='H',makeplot=False,saveplot=False):
    """
    This function generates the fusion proton particle tracks for a given
    CQL3D output. The number of protons across z is scaled based on the
    fusion reactivity as a function of z from CQL3D.

    Parameters
    ----------
    filename : string
        Name of the CQL3D output file.
    species : string, optional
        Fusion product species. 
        The default is 'H'.
    makeplot : boolean, optional
        Make a plot of the data.
    saveplot : boolean, optional
        Save the plot.

    Returns
    -------
    particleTracks : np.array
        Data on the state vector for each fusion proton.
    """
    
    #Get the axial fusion neutron flux
    fusArr,zArr=cqlTools.axial_neutron_flux(filename)
    
    #Initial energy
    energy=fusion_energy(species)
    
    #Max value of fusArr for normalization
    maxRxRate=np.max(fusArr)
    
    #Get the particle tracks
    particleTracks=[]
    
    #Go over each z position
    for i in range(len(zArr)):
        
        print('Current z position- '+str(np.round(zArr[i],3))+'m')
        
        #Number of particles at a given z position
        #There are 250 particles launched at the turning points
        numParticles=int(250*fusArr[i]/maxRxRate)
        
        print('Number of particles- '+str(numParticles))
        
        for j in range(numParticles):
            
            #Launch position
            xIni=np.array([0,0,zArr[i]])
            
            #Theta value
            #Formula prevents excess points being generated at the poles
            theta=np.arccos(np.random.uniform(-1,1))
            
            #Phi value
            phi=np.random.uniform(0,2*np.pi)
            
            #Single particle track
            stateVec=single_particle_track(xIni=xIni,energy=energy,theta=theta,phi=phi,species=species)
            
            particleTracks.append(stateVec)
            
    #Convert to numpy
    particleTracks=np.array(particleTracks)
    
    #Generate the savename of the data
    #Get the name of the .nc file
    ncName=filename.split('/')[-1]
    #Remove the .nc part
    ncName=ncName[0:-3]
    savename=ncName+'_particleTracks.npy'
    #Save the data
    np.save(dataDest+savename,particleTracks)
    
    if makeplot==True:
        
        #Create the plot
        fig=plt.figure(figsize=(21,8))
        ax=fig.add_subplot(111)
        
        #Plot the poloidal flux
        #Plot limits
        psilim=eqDict['psi_lim']
        #Plot levels
        levels=np.linspace(0,psilim,40)
        
        pltobj=ax.contour(Zmesh,Rmesh,eqdsk_psi,levels=levels)
        pltobj=ax.contour(Zmesh,-Rmesh,eqdsk_psi,levels=levels)
        cbar=fig.colorbar(pltobj)
        cbar.set_label(r'$\Psi_B$ [$T \cdot m^2$]')
        
        #Number of particles
        numParticles=np.shape(particleTracks)[0]
        #Evenly spaced array for changing colors
        colorArr=np.linspace(0,1,numParticles)
        #Plot each ray
        for i in range(numParticles):
            ax.plot(particleTracks[i][2],particleTracks[i][1],color=(colorArr[i],0,0))
        
        ax.set_xlabel('Z [m]')
        ax.set_ylabel('X [m]')
        
        ax.set_xlim(np.min(Zmesh),np.max(Zmesh))
        ax.set_ylim(-np.max(Rmesh),np.max(Rmesh))
        
        ax.grid(True)
        
        if saveplot==True:
            
            #Generate the savename of the plot
            #Get the name of the .nc file
            ncName=filename.split('/')[-1]
            #Remove the .nc part
            ncName=ncName[0:-3]
            savename=ncName+'_fusion_particle_tracks.png'
            
            plt.savefig(plotDest+savename,bbox_inches='tight')
        
        plt.show()
    
    return particleTracks

def generate_tracks_detector(filename,detPos,detSize,detTheta,detPhi,
                             acceptAng=np.pi/4,species='H',
                             numLaunchPos=10,numLaunchesPerPos=10,
                             makeplot=False,saveplot=False):
    """
    This function generates the fusion proton particle tracks for a given eqdsk
    output and a given detector position.
    
    It does this by taking 10 random points on the detector surface and
    generating 10 random initial velocity vectors for each point. These
    velocity vectors are all within the acceptance angle specified by the user.

    Parameters
    ----------
    filename : string
        Name of the eqdsk output file.
    detPos : np.array
        Position of the center of the detector.
    detSize : float
        Size of the detector in m^3. Assume circular shape.
    detTheta : float
        Angle with respect to the z axis (0 is radially outwards in cylindrical
                                          geometry)
    detPhi : float
        Angle with respect to the x axis
    acceptAng : float
        Acceptance angle for the detector.
        The default is 45 degrees.
    species : string, optional
        Fusion product species. 
        The default is 'H'.
        This function applies the time reversal automatically.
    numLaunchPos : int, optional
        Number of launch positions from the detector.
        The default is 10.
    numLaunchesPerPos : int, optional
        Number of particles launched per launch position.
        The default is 10.
    makeplot : boolean, optional
        Make a plot of the data.
    saveplot : boolean, optional
        Save the plot.

    Returns
    -------
    particleTracks : np.array
        Data on the state vector for each fusion proton.
    """
    
    #Initial energy
    energy=fusion_energy(species)
    
    #Apply time reversal to the particle
    species='t'+species
    
    #eqdsk mesh arrays
    Rmesh,Zmesh,eqdsk_psi=eqTools.flux_surfaces(filename=filename)
    
    #Normal vector of the detector
    detNorm=np.array([np.sin(detTheta)*np.cos(detPhi),np.sin(detTheta)*np.sin(detPhi),np.cos(detTheta)])
    
    #Smallest distance of the origin to the plane
    smallDist=np.dot(detNorm,detPos)
    
    #Plane object to get random points on the plane
    plane=Plane(tuple(detNorm),smallDist,tuple(detPos),np.sqrt(detSize/np.pi))
    
    #Get random points on the detector
    planePoints=np.asarray(plane.create_random_points(numLaunchPos))
    
    #Get the particle tracks
    particleTracks=[]
    
    #Particle number
    particleNum=1
    
    #Go over each point
    for point in planePoints:
        
        #Random perturbations per point
        for i in range(numLaunchesPerPos):
        
            #Random theta perturbation
            thetaPer=random.uniform(-1,1)*acceptAng #radians
            #Random phi perturbation
            phiPer=random.uniform(-1,1)*np.sqrt(acceptAng**2-thetaPer**2)
            
            #Launch theta
            thetaLaunch=detTheta+thetaPer
            #Launch phi
            phiLaunch=detPhi+phiPer
            
            #Print the track number
            print('Generating track number- '+str(particleNum))
            #Increment
            particleNum+=1
            
            #Single particle track
            stateVec=single_particle_track(xIni=point,energy=energy,theta=thetaLaunch,phi=phiLaunch,species=species)
            
            particleTracks.append(stateVec)
            
    #Convert to numpy
    particleTracks=np.array(particleTracks)
    
    if makeplot==True:
        
        #Create the plot
        fig=plt.figure(figsize=(21,8))
        ax=fig.add_subplot(111)
        
        #Plot the poloidal flux
        #Plot limits
        psilim=eqDict['psi_lim']
        #Plot levels
        levels=np.linspace(0,psilim,40)
        
        pltobj=ax.contour(Zmesh,Rmesh,eqdsk_psi,levels=levels)
        pltobj=ax.contour(Zmesh,-Rmesh,eqdsk_psi,levels=levels)
        cbar=fig.colorbar(pltobj)
        cbar.set_label(r'$\Psi_B$ [$T \cdot m^2$]')
        
        #Plot each ray
        for i in range(len(particleTracks)):
            
            ax.plot(particleTracks[i][2],particleTracks[i][0],color='red')
            
            #Plot the end points
            #Only add label to 1 track
            if i==1:
                ax.scatter(particleTracks[i][2][-1],particleTracks[i][0][-1],zorder=5,color='blue',label='End Point')
            else:
                ax.scatter(particleTracks[i][2][-1],particleTracks[i][0][-1],zorder=5,color='blue')
            #Plot the start points
            #Only add label to 1 track
            if i==1:
                ax.scatter(particleTracks[i][2][0],particleTracks[i][0][0],s=75,zorder=5,color='black',label='Start Point')
            else:
                ax.scatter(particleTracks[i][2][0],particleTracks[i][0][0],s=75,zorder=5,color='black')
                
        #Plot the detector
        if type(detPos)!=int:
            
            #Detector normal
            ax.quiver(detPos[2],detPos[0],detNorm[2],detNorm[0],width=3e-3,zorder=10)
            # ax.quiverkey(detNormalObj,0.9,0.9,1,label='Detector Normal',labelpos='E')
            
            #Detector boundary
            #100 points on a unit circle in the xy-plane
            detPosArr=np.array([np.cos(np.linspace(0,2*np.pi,100)),np.sin(np.linspace(0,2*np.pi,100)),np.zeros(100)])
            #Scale unit circle to detector size
            detPosArr*=np.sqrt(detSize/np.pi)
            #Initialize the rotation
            rotObj=R.from_euler('ZYX',[detPhi,detTheta,0])
            #Apply the rotation to each point
            rotArr=[]
            for i in range(len(detPosArr[0])):
                rotArr.append(rotObj.apply(detPosArr[:,i]))
            rotArr=np.array(rotArr)
            #Move to the detector location
            rotArr+=detPos
            #Plot the detector boundary
            ax.plot(rotArr[:,2],rotArr[:,0],label='Detector',linewidth=6,zorder=10)
        
        ax.set_xlabel('Z [m]')
        ax.set_ylabel('X [m]')
        
        ax.set_xlim(np.min(Zmesh),np.max(Zmesh))
        ax.set_ylim(-np.max(Rmesh),np.max(Rmesh))
        
        ax.legend()
        ax.grid(True)
        
        if saveplot==True:
                
                #Generate the savename of the plot
                #Get the name of the .nc file
                ncName=filename.split('/')[-1]
                #Remove the .nc part
                ncName=ncName[0:-3]
                savename=ncName+'_launch_from_detector.png'
                
                plt.savefig(plotDest+savename,bbox_inches='tight')
        
        plt.show()
    
    return particleTracks

def on_segment(p,q,r):
    """
    This function checks if r lies on the line segment defined by (p,q).
    
    Code copied from- https://www.kite.com/python/answers/how-to-check-if-two-line-segments-intersect-in-python
    which is why inline comments are sparse.

    Parameters
    ----------
    p : list
        Format- [xVal,yVal]
        One end of the line segment.
    q : list
        Format- [xVal,yVal]
        Other end of the line segment.
    r : list
        Format- [xVal,yVal]
        Point which is being checked.

    Returns
    -------
    boolean : True - r is on the line
              False- r is not on the line.    
    """

    if r[0]<=max(p[0],q[0]) and r[0]>=min(p[0],q[0]) and r[1]<=max(p[1],q[1]) and r[1]>=min(p[1],q[1]):
        return True
    
    return False

def orientation(p,q,r):
    """
    This function checks the orientation of the 3 points p,q,r. Are they 
    clockwise, counterclockwise or colinear with respect to each other.
    
    Code copied from- https://www.kite.com/python/answers/how-to-check-if-two-line-segments-intersect-in-python
    which is why inline comments are sparse.

    Parameters
    ----------
    p : list
        Format- [xVal,yVal]
        Point 1.
    q : list
        Format- [xVal,yVal]
        Point 2.
    r : list
        Format- [xVal,yVal]
        Point 3.

    Returns
    -------
    int : 0 - colinear
          1 - clockwise
          2 - counterclockwise
    """

    val=((q[1]-p[1])*(r[0]-q[0]))-((q[0]-p[0])*(r[1]-q[1]))
    
    if val==0: 
        return 0
    
    return 1 if val>0 else -1

def line_intersection(seg1,seg2):
    """
    This function checks if 2 line segments intersect.
    
    Code copied from- https://www.kite.com/python/answers/how-to-check-if-two-line-segments-intersect-in-python
    which is why inline comments are sparse.

    Parameters
    ----------
    seg1 : list
        Format- [[x1,y1],[x2,y2]]
        Points defining line segment 1.
    seg2 : list
        Format- [[x1,y1],[x2,y2]]
        Points defining line segment 2.

    Returns
    -------
    boolean : True - seg1,seg2 intersect
              False- seg2,seg2 do not intersect
    """

    #Get the 4 points that define the line segments
    p1,q1=seg1
    p2,q2=seg2

    #Find all possible oprientations
    o1=orientation(p1,q1,p2)
    o2=orientation(p1,q1,q2)
    o3=orientation(p2,q2,p1)
    o4=orientation(p2,q2,q1)

    #Check the general case
    if o1!=o2 and o3!=o4:
        return True

    #Check the special cases
    if o1==0 and on_segment(p1,q1,p2) : return True
    if o2==0 and on_segment(p1,q1,q2) : return True
    if o3==0 and on_segment(p2,q2,p1) : return True
    if o4==0 and on_segment(p2,q2,q1) : return True

    return False

def line_plane_intersection(p0,p1,p_co,p_no,epsilon=1e-6):
    """
    This function checks if a line intersects a plane.
    
    The line is defined by 2 points- p0,p1.
    The plane is defined by a vector normal to the plane p_n0 and a point on
    the plane p_co.
    
    Code is copied from- https://stackoverflow.com/questions/5666222/3d-line-plane-intersection
    which is why inline comments are sparse.

    Parameters
    ----------
    p0 : np.array
        Format- [xVal,yVal,zVal]
        One point that defines the line.
    p1 : np.array
        Format- [xVal,yVal,zVal]
        Other point that defines the line.
    p_co : np.array
        Format- [xVal,yVal,zVal]
        Point on the plane.
    p_no : np.array
        Format- [xVal,yVal,zVal]
        Vector normal to the plane.
    epsilon : np.array, optional
        Limit for how || the line can be to the plane. 
        The default is 1e-6.

    Returns
    -------
    np.array : [x,y,z] point of intersection if the line intersects the plane.
               0 if the line is || to the plane
    """

    u=p1-p0
    dot=np.dot(p_no,u)

    if abs(dot)>epsilon:
        
        w=p0-p_co
        fac=-np.dot(p_no,w)/dot
        u=u*fac
        
        return p0+u

    #Line segment is || to the plane.
    return 0

def close_to_line(point,lp1,lp2,epsilon=1e-4):
    """
    This function checks if a point is close to a line segment defined by lp1
    and lp2.
    
    Code is copied from- http://www.fundza.com/vectors/point2line/index.html
    which is why inline comments are sparse.

    Parameters
    ----------
    point : np.array
        Point to be checked.
    lp1 : np.array
        One end of the line segment.
    lp2 : np.array
        Other end of the line segment.
    epsilon : np.array
        Closeness parameter.
        The default value is 1e-4

    Returns
    -------
    bool
        Whether the point is close to the line segment.
    """
    
    line_vec=lp1-lp2
    pnt_vec=lp1-point
    line_len=np.sqrt(line_vec.dot(line_vec))
    line_unitvec=line_vec/line_len
    pnt_vec_scaled=pnt_vec*(1/line_len)
    t=np.dot(line_unitvec,pnt_vec_scaled)
    
    if t<0:
        t=0
    elif t>1:
        t=1
    
    nearest=line_vec*t
    dist=np.sqrt((nearest-pnt_vec).dot(nearest-pnt_vec))
    nearest=nearest+lp1
    
    if dist<=epsilon:
        return True
    else:
        return False

def close_to_detector(point,detSize,detPos):
    """
    This function checks if the point of intersection as calculated by
    line_plane_intersection is close to the detector. i.e. is a valid hit on
    the neutron detector.

    Parameters
    ----------
    point : np.array
        Point to be checked for closeness to the detector.
    detSize : float
        Size of the detector in m^3. Assume circular shape.
    detPos : np.array
        Position of the center of the detector.

    Returns
    -------
    bool
        Whether the point is close to the detector.
    """
    
    #Get the maximum allowable distance
    distLim=np.sqrt(detSize/np.pi)
    
    #Distance between the 2 points
    dist=np.sqrt((point-detPos).dot(point-detPos))
    
    if dist<=distLim:
        return True
    else:
        return False

def hit_detector(particleTrack,detPos,detNorm):
    """
    This function checks if the particle hits the detector.
    If the particle hits the detector, this function also returns the position
    and velocity at the time of the hit.

    Parameters
    ----------
    particleTrack : np.array
        Singple particle track data.
    detPos : np.array
        Position of the center of the detector.
    detNorm : np.array
        Normal vector of the detector.

    Returns
    -------
    detectorHit : bool
        Whether the particle hit the detector.
        True- The particle hit the detector.
        False- The particle did not hit the detector.
    hitPos : np.array
        Position of the hit.
        Default is [0,0,0]
    hitVel : np.array
        Velocity of the hit.
        Default is [0,0,0]
    hitTrack : np.array
        Particle track upto the detector hit.
    """
    
    #Initialize the variables
    detectorHit=False
    hitPos=np.array([0,0,0])
    hitVel=np.array([0,0,0])
    hitTrack=[]
    
    #Go over the current track
    for j in range(len(particleTrack[0])-1):
        
        #Position of the particle
        point1=particleTrack[0:3,j]
        
        #Check if the track hits the wall
        if hit_vessel(point1)==True:
            #No need to track if the particle hits the vessel
            break
        
        #Next point to define a line segment to test intersection
        point2=particleTrack[0:3,j+1]
        
        #Check if the line intersects the plane
        intPoint=line_plane_intersection(point1,point2,detPos,detNorm)
        if type(intPoint)==np.ndarray:
            
            #Check if the point of intersection is close to the track and detector
            onLine=close_to_line(intPoint,point1,point2)
            onDetector=close_to_detector(intPoint,detSize,detPos)
            if onLine==True and onDetector==True:
                
                #Update the values
                detectorHit=True
                hitPos=intPoint
                hitVel=particleTrack[3:,j]
                
                #Only add the track up when it hits the detector
                hitTrack=particleTrack[:,j+1]
                
                #Stop tracking if the particle hits the detector
                break
    
    return detectorHit,hitPos,hitVel,hitTrack

def hit_vessel(point):
    """
    This function tests if the particle has hit the vessel wall.

    Parameters
    ----------
    point : np.array
        Current position of the particle.
        Format- [x,y,z] in meters

    Returns
    -------
    bool
        Whether the particle has hit the detector.
        True- Particle has hit the vessel wall.
        False- Particle has not hit the vessel wall.
    """
    
    #Radial position
    radPos=np.sqrt(point[0]**2+point[1]**2)
    
    #Radial boundary of the vessel
    if radPos>=0.37:
        return True
    #Axial boundary of the vessel
    if abs(point[2])>=1.44:
        return True
    
    #Base case
    return False

def correct_face(stateVec,detVec):
    """
    This function checks if the particle hits the correct face of the detector 
    when the particle track intersects with it.
    
    This is done by taking the dot product of the velocity with the area
    normal at the moment of interesection.
    
    If v dot A < 0 then it hit the correct surface

    Parameters
    ----------
    stateVec : np.array
        State vector of the particle at a given time.
        Format- [x,y,z,vx,vy,vz]
              - Postions in meters
              - Velocities in m/s
    detVec : np.array
        Vector normal to the detector surface.

    Returns
    -------
    bool
        Whether the particle hit the correct face of the detector.
        True- Particle hit the correct face
        False- Particle hit the wrong face.
    """
    
    #Get the velocity of the particle
    velocity=stateVec[3:]
    
    if np.dot(velocity,detVec)<0:
        return True
    else:
        return False

def acceptance_angle(stateVec,detVec,angle=np.pi/2):
    """
    This function checks if the particle hits the detector at the correct
    angle.
    
    This is done by calculating the angle between the velocity vector and the
    detector normal at the moment of impact.
    
    In reality, this will be implemented by putting cylinders of various 
    lengths and widths in front of the detector to control the acceptance angle.
    Therefore, by just checking the angle at the point of impact, we are
    making the implicit assumption that the larmor radius of the fusion protons
    is larger than the detector scale length.

    Parameters
    ----------
    stateVec : np.array
        State vector of the particle at a given time.
        Format- [x,y,z,vx,vy,vz]
              - Postions in meters
              - Velocities in m/s
    detVec : np.array
        Vector normal to the detector surface.
    angle : float
        Acceptance angle between the velocity vector and detector normal (rad).
        The default value is pi/2 radians.

    Returns
    -------
    impactAngle : float
        Angle between the velocity and detector normal at the moment of impact.
    correctAngle : boolean
        Whether the particle velocity was within the acceptable angle limit.
        True- Velocity was within the acceptable angle.
        False- Velocity was outside the acceptable angle.
    """
    
    #Whether the particle hits at the right angle
    correctAngle=False
    
    #Get the velocity of the particle
    velocity=stateVec[3:]
    
    #Invert the direction of the velocity so the angle is <=pi/2
    velocity=-velocity
    
    #Take the unit vectors for both vectors
    velUnit=velocity/np.linalg.norm(velocity)
    detUnit=detVec/np.linalg.norm(detVec)
    
    #Find the angle between the vectors
    #Statement copied from- https://stackoverflow.com/a/13849249/71522
    impactAngle=np.arccos(np.clip(np.dot(velUnit,detUnit),-1.0,1.0))
    
    #Check if the particle is within range
    if impactAngle<=angle:
        correctAngle=True
    
    return impactAngle,correctAngle

def through_the_core(particleTrack,coreRad):
    """
    This function checks if the particle went through the core of the plasma as
    defined by coreRad.
    If the particle went through the core, it also returns the particle track
    upto that point.

    Parameters
    ----------
    particleTrack : np.array
        Single particle track data.
    coreRad : float
        Radius of the core [m].

    Returns
    -------
    throughTheCore : bool
        Whether the particle went through the core.
        True- The particle went through the core.
        False- The particle did not go through the core.
    coreTrack : np.array
        Particle track data upto the point of leaving the core.
    """
    
    #Initialize the variables
    throughTheCore=False
    inCore=False
    coreTrack=[]
    
    #Go over the current track
    for j in range(len(particleTrack[0])-1):
        
        #Position of the particle
        point1=particleTrack[0:3,j]
        
        #Radial position of the particle
        radPos=np.sqrt(point1[0]**2+point1[1]**2)
        
        #Check if it enters the core
        if radPos<=coreRad:
            
            #Change flag state
            inCore=True
            
        #Check if it leaves the core
        if inCore==True:
            
            if radPos>=coreRad:
                
                #Only add the part until it leaves the core
                coreTrack=particleTrack[:,:j+1]
                
                #Update the state
                throughTheCore=True
                
                #No need to track further if particle leaves the core
                break
    
    return throughTheCore,coreTrack

def pad_array(arr):
    """
    This function pads all the sub arrays with nan values if arr is ragged.
    
    Code copied from-
    https://stackoverflow.com/questions/24494356/how-to-find-min-max-values-in-array-of-variable-length-arrays-with-numpy
    
    I added an if-else that checks if the subarrays are lists or np.arrays
    
    Parameters
    ----------
    arr : list
        Ragged list to be padded.

    Returns
    -------
    np.array
        Uniform array which has been padded with nan values.
    """
    
    #Get the maximum length of a subarray
    M = max(len(a) for a in arr)
    
    #Check if subarrays are lists or np.arrays
    if type(arr[0])==np.ndarray:
        return np.array([a.tolist() + [np.nan] * (M - len(a)) for a in arr])
    else:
        return np.array([a + [np.nan] * (M - len(a)) for a in arr])

def plot_particle_tracks(particleTracks,endpoints=True,startpoints=True,detectorLoc=0,detectorVec=0,detectorArea=0,make3d=False,savename='temp.png',saveplot=False):
    """
    This function plots a given set of particle tracks (defined in the variable
    'particleTracks') over a set of magnetic flux contours (defined in the 
    variable 'filenameEqdsk').
                                                            
    One can also plot the detector position and area vector by specifying the
    following variables-
    1. detectorLoc
    2. detectorVec
    3. detectorArea
    
    make3D allows you to plot the particle tracks and detector location in full
    3D.

    Parameters
    ----------
    particleTracks : np.array/list
        Particle track data.
    endpoints : boolean
        Scatterplot of the end points for the particle tracks.
    startpoints : boolean
        Scatterplot of the start points for the particle tracks.
    detectorLoc : np.array
        Location of the detector (center of the area element).
        Format- [x,y,z] in meters
        Default value is 0.
    detectorVec : np.array
        Vector normal to the detector surface.
        Default value is 0.
    detectorArea : float
        Area of the detector in m^2.
        Default value is 0.
    make3d : boolean
        Make a 3D plot of the particle tracks and detector position.
    savename: string
        Name of the plot when saving. Format is- [eqdsk name]+savename.
        Note- Include filetype in savename.
        Default value is 'temp.png'
    saveplot : boolean
        Save the plot. Only works when make3d is 'False'

    Returns
    -------
    None.
    """
    
    #eqdsk data object
    eqDict=eqTools.read_eqdsk(filenameEqdsk)
    #Flux surface data
    Rmesh,Zmesh,eqdsk_psi=eqTools.flux_surfaces(filenameEqdsk)
    
    #Make a 3D plot
    if make3d==True:
        
        #Initialize the plot
        fig=plt.figure()
        ax=plt.axes(projection='3d')
        
        #Plot each ray
        for i in range(len(particleTracks)):
            
            ax.plot3D(particleTracks[i][0],particleTracks[i][1],particleTracks[i][2],color='red')
            
            #Plot the endpoints
            if endpoints==True:
                #Only add label to 1 track
                if i==1:
                    ax.scatter3D(particleTracks[i][0][-1],particleTracks[i][1][-1],particleTracks[i][2][-1],zorder=5,color='blue',label='End Point')
                else:
                    ax.scatter3D(particleTracks[i][0][-1],particleTracks[i][1][-1],particleTracks[i][2][-1],zorder=5,color='blue')
                    
        #Plot the detector
        if type(detectorLoc)!=int:
            
            #Detector normal
            ax.quiver(detectorLoc[0],detectorLoc[1],detectorLoc[2],detectorVec[0],detectorVec[1],detectorVec[2],pivot='tail',length=0.05,zorder=10)
            
            #Detector boundary
            #100 points on a unit circle in the xy-plane
            detPosArr=np.array([np.cos(np.linspace(0,2*np.pi,100)),np.sin(np.linspace(0,2*np.pi,100)),np.zeros(100)])
            #Scale unit circle to detector size
            detPosArr*=np.sqrt(detectorArea/np.pi)
            #Angles by which to rotate this circle based on the detector normal
            theta=np.arccos(detectorVec[2])
            phi=np.arccos(detectorVec[0]/np.sin(theta))
            #Initialize the rotation
            rotObj=R.from_euler('ZYX',[phi,theta,0])
            #Apply the rotation to each point
            rotArr=[]
            for i in range(len(detPosArr[0])):
                rotArr.append(rotObj.apply(detPosArr[:,i]))
            rotArr=np.array(rotArr)
            #Move to the detector location
            rotArr+=detectorLoc
            #Plot the detector boundary
            ax.plot3D(rotArr[:,0],rotArr[:,1],rotArr[:,2],label='Detector',linewidth=6,zorder=10)
            
        ax.set_xlabel('X [m]')
        ax.set_ylabel('Y [m]')
        ax.set_zlabel('Z [m]')
        
        ax.set_xlim(np.min(Rmesh),np.max(Rmesh))
        ax.set_ylim(-np.max(Rmesh),np.max(Rmesh))
        ax.set_zlim(np.min(Zmesh),np.max(Zmesh))
        
        ax.legend()
        ax.grid(True)
        
        plt.show()
        
    #Make a 2D plot
    else:
        
        #Relative sizes of each plot
        relSize=dict(width_ratios=[1.5,1],height_ratios=[1,1])
        
        #Create the plot
        fig,axs=plt.subplot_mosaic([['upper left','right'],['lower left','right']],gridspec_kw=relSize,figsize=(28,11),constrained_layout=True)
        
        #Go over each subplot
        for label,ax in axs.items():
            
            #XZ plot
            if label=='lower left':

                #Plot the poloidal flux
                #Plot limits
                psilim=eqDict['psi_lim']
                #Plot levels
                levels=np.linspace(0,psilim,40)
                
                ax.contour(Zmesh,Rmesh,eqdsk_psi,levels=levels)
                ax.contour(Zmesh,-Rmesh,eqdsk_psi,levels=levels)
                
                #Plot each ray
                for i in range(len(particleTracks)):
                    
                    ax.plot(particleTracks[i][2],particleTracks[i][0],color='red')
                
                    #Plot the endpoints
                    if endpoints==True:
                        #Only add label to 1 track
                        if i==1:
                            ax.scatter(particleTracks[i][2][-1],particleTracks[i][0][-1],zorder=5,color='blue',label='End Point')
                        else:
                            ax.scatter(particleTracks[i][2][-1],particleTracks[i][0][-1],zorder=5,color='blue')
                    #Plot the startpoints
                    if startpoints==True:
                        #Only add label to 1 track
                        if i==1:
                            ax.scatter(particleTracks[i][2][0],particleTracks[i][0][0],s=75,zorder=5,color='black',label='Start Point')
                        else:
                            ax.scatter(particleTracks[i][2][0],particleTracks[i][0][0],s=75,zorder=5,color='black')
                
                #Plot the detector
                if type(detectorLoc)!=int:
                    
                    #Detector normal
                    ax.quiver(detectorLoc[2],detectorLoc[0],detectorVec[2],detectorVec[0],width=3e-3,zorder=10)
                    # ax.quiverkey(detNormalObj,0.9,0.9,1,label='Detector Normal',labelpos='E')
                    
                    #Detector boundary
                    #100 points on a unit circle in the xy-plane
                    detPosArr=np.array([np.cos(np.linspace(0,2*np.pi,100)),np.sin(np.linspace(0,2*np.pi,100)),np.zeros(100)])
                    #Scale unit circle to detector size
                    detPosArr*=np.sqrt(detectorArea/np.pi)
                    #Angles by which to rotate this circle based on the detector normal
                    theta=np.arccos(detectorVec[2])
                    phi=np.arccos(detectorVec[0]/np.sin(theta))
                    #Initialize the rotation
                    rotObj=R.from_euler('ZYX',[phi,theta,0])
                    #Apply the rotation to each point
                    rotArr=[]
                    for i in range(len(detPosArr[0])):
                        rotArr.append(rotObj.apply(detPosArr[:,i]))
                    rotArr=np.array(rotArr)
                    #Move to the detector location
                    rotArr+=detectorLoc
                    #Plot the detector boundary
                    ax.plot(rotArr[:,2],rotArr[:,0],label='Detector',linewidth=6,zorder=10)
                
                #Axes labels
                ax.set_xlabel('Z [m]')
                ax.set_ylabel('X [m]')
                
                #Subplot title
                ax.set_title('XZ Plane')
                
                # ax.set_xlim(np.min(Zmesh),np.max(Zmesh))
                # ax.set_ylim(-np.max(Rmesh),np.max(Rmesh))
                
                #Zoom into the area with particle tracks
                #x points of each track
                xVals=[particleTracks[i][0][:] for i in range(0,len(particleTracks))]                
                #Pad array with nan values
                xVals=pad_array(xVals)
                xMax=np.nanmax(xVals)
                xMin=np.nanmin(xVals)
                #z points of each track
                zVals=[particleTracks[i][2][:] for i in range(0,len(particleTracks))]
                #Pad array with nan values
                zVals=pad_array(zVals)
                zMax=np.nanmax(zVals)
                zMin=np.nanmin(zVals)
                
                ax.set_xlim(zMin-0.25,zMax+0.25)
                ax.set_ylim(xMin-0.05,xMax+0.05)
                
                ax.legend()
                ax.grid(True)
        
            #YZ plot
            if label=='upper left':
                
                #Plot the poloidal flux
                #Plot limits
                psilim=eqDict['psi_lim']
                #Plot levels
                levels=np.linspace(0,psilim,40)
                
                ax.contour(Zmesh,Rmesh,eqdsk_psi,levels=levels)
                ax.contour(Zmesh,-Rmesh,eqdsk_psi,levels=levels)
                
                #Plot each ray
                for i in range(len(particleTracks)):
                    
                    ax.plot(particleTracks[i][2],particleTracks[i][1],color='red')
                
                    #Plot the endpoints
                    if endpoints==True:
                        #Only add label to 1 track
                        if i==1:
                            ax.scatter(particleTracks[i][2][-1],particleTracks[i][1][-1],zorder=5,color='blue',label='End Point')
                        else:
                            ax.scatter(particleTracks[i][2][-1],particleTracks[i][1][-1],zorder=5,color='blue')
                    #Plot the startpoints
                    if startpoints==True:
                        #Only add label to 1 track
                        if i==1:
                            ax.scatter(particleTracks[i][2][0],particleTracks[i][1][0],s=75,zorder=5,color='black',label='Start Point')
                        else:
                            ax.scatter(particleTracks[i][2][0],particleTracks[i][1][0],s=75,zorder=5,color='black')
                
                #Plot the detector
                if type(detectorLoc)!=int:
                    
                    #Detector normal
                    ax.quiver(detectorLoc[2],detectorLoc[1],detectorVec[2],detectorVec[1],width=3e-3,zorder=10)
                    # ax.quiverkey(detNormalObj,0.9,0.9,1,label='Detector Normal',labelpos='E')
                    
                    #Detector boundary
                    #100 points on a unit circle in the xy-plane
                    detPosArr=np.array([np.cos(np.linspace(0,2*np.pi,100)),np.sin(np.linspace(0,2*np.pi,100)),np.zeros(100)])
                    #Scale unit circle to detector size
                    detPosArr*=np.sqrt(detectorArea/np.pi)
                    #Angles by which to rotate this circle based on the detector normal
                    theta=np.arccos(detectorVec[2])
                    phi=np.arccos(detectorVec[0]/np.sin(theta))
                    #Initialize the rotation
                    rotObj=R.from_euler('ZYX',[phi,theta,0])
                    #Apply the rotation to each point
                    rotArr=[]
                    for i in range(len(detPosArr[0])):
                        rotArr.append(rotObj.apply(detPosArr[:,i]))
                    rotArr=np.array(rotArr)
                    #Move to the detector location
                    rotArr+=detectorLoc
                    #Plot the detector boundary
                    ax.plot(rotArr[:,2],rotArr[:,1],label='Detector',linewidth=6,zorder=10)
                
                ax.set_xlabel('Z [m]')
                ax.set_ylabel('Y [m]')
                
                #Subplot title
                ax.set_title('YZ Plane')
                
                # ax.set_xlim(np.min(Zmesh),np.max(Zmesh))
                # ax.set_ylim(-np.max(Rmesh),np.max(Rmesh))
                
                #Zoom into the area with particle tracks
                #y points of each track
                yVals=[particleTracks[i][1][:] for i in range(0,len(particleTracks))]
                #Pad aray with nan values
                yVals=pad_array(yVals)
                yMax=np.nanmax(yVals)
                yMin=np.nanmin(yVals)
                #z points of each track
                zVals=[particleTracks[i][2][:] for i in range(0,len(particleTracks))]
                #Pad array with nan values
                zVals=pad_array(zVals)
                zMax=np.nanmax(zVals)
                zMin=np.nanmin(zVals)
                
                ax.set_xlim(zMin-0.25,zMax+0.25)
                ax.set_ylim(yMin-0.05,yMax+0.05)
                
                ax.legend()
                ax.grid(True)
        
            #XY plot
            if label=='right':
                
                #Plot each ray
                for i in range(len(particleTracks)):
                    
                    ax.plot(particleTracks[i][0],particleTracks[i][1],color='red')
                
                    #Plot the endpoints
                    if endpoints==True:
                        #Only add label to 1 track
                        if i==1:
                            ax.scatter(particleTracks[i][0][-1],particleTracks[i][1][-1],zorder=5,color='blue',label='End Point')
                        else:
                            ax.scatter(particleTracks[i][0][-1],particleTracks[i][1][-1],zorder=5,color='blue')
                    #Plot the startpoints
                    if startpoints==True:
                        #Only add label to 1 track
                        if i==1:
                            ax.scatter(particleTracks[i][0][0],particleTracks[i][1][0],s=75,zorder=5,color='black',label='Start Point')
                        else:
                            ax.scatter(particleTracks[i][0][0],particleTracks[i][1][0],s=75,zorder=5,color='black')
                
                #Plot the detector
                if type(detectorLoc)!=int:
                    
                    #Detector normal
                    ax.quiver(detectorLoc[0],detectorLoc[1],detectorVec[0],detectorVec[1],width=3e-3,zorder=10)
                    # ax.quiverkey(detNormalObj,0.9,0.9,1,label='Detector Normal',labelpos='E')
                    
                    #Detector boundary
                    #100 points on a unit circle in the xy-plane
                    detPosArr=np.array([np.cos(np.linspace(0,2*np.pi,100)),np.sin(np.linspace(0,2*np.pi,100)),np.zeros(100)])
                    #Scale unit circle to detector size
                    detPosArr*=np.sqrt(detectorArea/np.pi)
                    #Angles by which to rotate this circle based on the detector normal
                    theta=np.arccos(detectorVec[2])
                    phi=np.arccos(detectorVec[0]/np.sin(theta))
                    #Initialize the rotation
                    rotObj=R.from_euler('ZYX',[phi,theta,0])
                    #Apply the rotation to each point
                    rotArr=[]
                    for i in range(len(detPosArr[0])):
                        rotArr.append(rotObj.apply(detPosArr[:,i]))
                    rotArr=np.array(rotArr)
                    #Move to the detector location
                    rotArr+=detectorLoc
                    #Plot the detector boundary
                    ax.plot(rotArr[:,0],rotArr[:,1],label='Detector',linewidth=6,zorder=10)
                    
                #Plot the r=10cm circle
                #Create the circle object
                circ=plt.Circle((0,0),  #Center
                          0.1,          #Radius in m
                          color='g',    #Color
                          linewidth=5,  #Line width
                          fill=False)   #Only make an outline
                #Add to the plot
                ax.add_patch(circ)
                
                ax.set_xlabel('X [m]')
                ax.set_ylabel('Y [m]')
                
                #Subplot title
                ax.set_title('XY Plane')
                
                # ax.set_xlim(-np.max(Rmesh),np.max(Rmesh))
                # ax.set_ylim(-np.max(Rmesh),np.max(Rmesh))
                
                #Zoom in to make plots clearer
                ax.set_xlim(-0.3,0.3)
                ax.set_ylim(-0.3,0.3)
                
                ax.legend()
                ax.grid(True)
        
        #Plot title
        if type(detectorVec)!=int:
            phi=np.angle(detectorVec[0]+1j*detectorVec[1])*(180/np.pi)
            theta=np.arccos(np.dot(detectorVec,np.array([0,0,1])))*(180/np.pi)
            fig.suptitle(r'$\theta$='+str(int(theta))+r'$^{\circ}$; $\phi$='+str(int(phi))+r'$^{\circ}$')
        
        if saveplot==True:
                
                plt.savefig(plotDest+savename,bbox_inches='tight')
        
        plt.show()
    
    return

#%% Proton detector placement analysis (Straight line collimator)

#Detector parameters

#Position (x,y,z)
detPos=np.array([0.25,0,0.3]) #meters

#Orientation (spherical angles for the detector normal)
#Theta (angle wrt z axis)
detTheta=(np.pi/180)*90 #radians
#Phi (angle wrt x axis in the xy plane)
detPhi=(np.pi/180)*(135) #radians

#Size
detSize=75*1e-6 #m^2

#Acceptance angle
accAngle=(np.pi/180)*10

#Normal vector of the detector
detNorm=np.array([np.sin(detTheta)*np.cos(detPhi),np.sin(detTheta)*np.sin(detPhi),np.cos(detTheta)])

#Particle species
species='H'

#Get the particle tracks
particleTracks=generate_tracks_detector(filenameEqdsk,detPos,detSize,detTheta,detPhi,accAngle,species=species)

#Array to store the particle tracks until they leave the core
coreTracks=[]

#Radius of the core
coreRad=0.1 #meters

#Go over each particle track
for i in range(len(particleTracks)):
    
    print('Track number- '+str(i+1))
    
    #Get the current track
    currTrack=particleTracks[i]
    
    #Check if the particle goes through the core
    throughTheCore,coreTrack=through_the_core(currTrack,coreRad)
    
    #Add the track to the array
    if throughTheCore==True:
        coreTracks.append(coreTrack)

#%% Proton detector placement analysis (Bent collimator)

#NOTE- In order to make the geometry simpler, I have not included the ability
#      to model a rotating shaft scheme with a bent collimator.

# =============================================================================
# Detector parameters
# =============================================================================

#Position (x,y,z)
detPos=np.array([0.25,0,0.0]) #meters

#Orientation (spherical angles for the detector normal)
#Theta (angle wrt z axis)  ***DO NOT CHANGE***
detTheta=(np.pi/180)*90 #radians
#Phi (angle wrt x axis in the xy plane)
detPhi=(np.pi/180)*(150) #radians

#Size
detSize=75*1e-6 #m^2

# =============================================================================
# Collimation tube parameters
# =============================================================================

#Bend radius
bendRad=0.3 #m

#Tube angle
tubeAng=np.pi/15 #rad

# =============================================================================
# Calculate the position/orientation of the tube opening
# =============================================================================

#Length of chord from tube opening to detector (law of cosines)
chordLen=bendRad*np.sqrt(2*(1-np.cos(tubeAng)))

#Place the detector 1 chord length from the origin
localPos=np.array([chordLen,0,0])

#Net angle by which we need to rotate the opening positon
netAng=detPhi+tubeAng

#Rotation matrix (-ve angle since we are rotating the point and not the axes)
rotMatrix=np.array([[np.cos(-netAng),np.sin(-netAng)],[-np.sin(-netAng),np.cos(-netAng)]])

#Rotate the opening position
localPos[:2]=np.matmul(rotMatrix,localPos[:2])

#Go from local to global coordinates
adjustedPos=localPos+detPos

#Normal vector of the detector
detNorm=np.array([np.sin(detTheta)*np.cos(detPhi),np.sin(detTheta)*np.sin(detPhi),np.cos(detTheta)])

#Normal vector of the opening
openNorm=np.array([np.sin(detTheta)*np.cos(netAng),np.sin(detTheta)*np.sin(netAng),np.cos(detTheta)])

# =============================================================================
# Generate the particle tracks
# =============================================================================

#Particle species
species='H'

#Get the particle tracks
particleTracks=generate_tracks_detector(filenameEqdsk,detPos,detSize,detTheta,detPhi,
                                        species=species,acceptAng=(np.pi/180)*15,
                                        numLaunchPos=20,numLaunchesPerPos=20)

# =============================================================================
# Analysis
# =============================================================================

#Array to store the particle tracks until they leave the core
coreTracks=[]

#Radius of the core
coreRad=0.1 #meters

#Go over each particle track
for i in range(len(particleTracks)):
    
    print('Track number- '+str(i+1))
    
    #Get the current track
    currTrack=particleTracks[i]

    #Check if the particle when through the core
    throughTheCore,coreTrack=through_the_core(currTrack,coreRad)
    
    if throughTheCore==True:
        coreTracks.append(coreTrack)
            
#Array to store the tracks that go through the opening
openingTracks=[]

#Go over each particle track to see if it goes through the opening
for i in range(len(coreTracks)):
    
    print('Track number- '+str(i+1))
    
    #Get the current track
    currTrack=coreTracks[i]
    
    #Check if the particle went through the opening
    detectorHit,hitPos,hitVel,hitTrack=hit_detector(currTrack,adjustedPos,openNorm)
    
    if detectorHit==True:
        openingTracks.append(currTrack)

print('# of generated tracks- ',len(particleTracks))
print('# of tracks through the core- ',len(coreTracks))
print('# of tracks through the opening- ',len(openingTracks))

# =============================================================================
# Create the plot
# =============================================================================

#Relative sizes of each plot
relSize=dict(width_ratios=[1.5,1],height_ratios=[1,1])

detectorLoc=detPos
detectorVec=detNorm
detectorArea=detSize

fig,axs=plt.subplot_mosaic([['upper left','right'],['lower left','right']],gridspec_kw=relSize,figsize=(28,11),constrained_layout=True)

#Stuff needed for the subplots
#eqdsk data object
eqDict=eqTools.read_eqdsk(filenameEqdsk)
#Flux surface data
Rmesh,Zmesh,eqdsk_psi=eqTools.flux_surfaces(filenameEqdsk)

#Go over each subplot
for label,ax in axs.items():
    
    #XZ plot
    if label=='lower left':
         
        #Plot each ray
        if len(openingTracks)!=0:
            for i in range(len(openingTracks)):
                
                ax.plot(openingTracks[i][2],openingTracks[i][0],color='red')
            
                #Plot the endpoints
                #Only add label to 1 track
                if i==1:
                    ax.scatter(openingTracks[i][2][-1],openingTracks[i][0][-1],zorder=5,color='blue',label='End Point')
                else:
                    ax.scatter(openingTracks[i][2][-1],openingTracks[i][0][-1],zorder=5,color='blue')
                #Plot the startpoints
                #Only add label to 1 track
                if i==1:
                    ax.scatter(openingTracks[i][2][0],openingTracks[i][0][0],s=75,zorder=5,color='black',label='Start Point')
                else:
                    ax.scatter(openingTracks[i][2][0],openingTracks[i][0][0],s=75,zorder=5,color='black')
        
        #Plot the poloidal flux
        #Plot limits
        psilim=eqDict['psi_lim']
        #Plot levels
        levels=np.linspace(0,psilim,40)
        
        pltobj=ax.contour(Zmesh,Rmesh,eqdsk_psi,levels=levels)
        pltobj=ax.contour(Zmesh,-Rmesh,eqdsk_psi,levels=levels)
        
        #Plot the detector
        if type(detectorLoc)!=int:
            
            #Detector normal
            ax.quiver(detectorLoc[2],detectorLoc[0],detectorVec[2],detectorVec[0],width=3e-3,zorder=10)
            # ax.quiverkey(detNormalObj,0.9,0.9,1,label='Detector Normal',labelpos='E')
            
            #Detector boundary
            #100 points on a unit circle in the xy-plane
            detPosArr=np.array([np.cos(np.linspace(0,2*np.pi,100)),np.sin(np.linspace(0,2*np.pi,100)),np.zeros(100)])
            #Scale unit circle to detector size
            detPosArr*=np.sqrt(detectorArea/np.pi)
            #Angles by which to rotate this circle based on the detector normal
            theta=np.arccos(detectorVec[2])
            phi=np.arctan2(detectorVec[1],detectorVec[0])
            #Initialize the rotation
            rotObj=R.from_euler('ZYX',[phi,theta,0])
            #Apply the rotation to each point
            rotArr=[]
            for i in range(len(detPosArr[0])):
                rotArr.append(rotObj.apply(detPosArr[:,i]))
            rotArr=np.array(rotArr)
            #Move to the detector location
            rotArr+=detectorLoc
            #Plot the detector boundary
            ax.plot(rotArr[:,2],rotArr[:,0],label='Detector',linewidth=6,zorder=10)
            
        #Plot the tube opening
        if type(adjustedPos)!=int:
            
            #Detector normal
            ax.quiver(adjustedPos[2],adjustedPos[0],openNorm[2],openNorm[0],width=3e-3,zorder=10)
            # ax.quiverkey(detNormalObj,0.9,0.9,1,label='Detector Normal',labelpos='E')
            
            #Detector boundary
            #100 points on a unit circle in the xy-plane
            detPosArr=np.array([np.cos(np.linspace(0,2*np.pi,100)),np.sin(np.linspace(0,2*np.pi,100)),np.zeros(100)])
            #Scale unit circle to detector size
            detPosArr*=np.sqrt(detectorArea/np.pi)
            #Angles by which to rotate this circle based on the detector normal
            theta=np.arccos(openNorm[2])
            phi=np.arctan2(openNorm[1],openNorm[0])
            #Initialize the rotation
            rotObj=R.from_euler('ZYX',[phi,theta,0])
            #Apply the rotation to each point
            rotArr=[]
            for i in range(len(detPosArr[0])):
                rotArr.append(rotObj.apply(detPosArr[:,i]))
            rotArr=np.array(rotArr)
            #Move to the detector location
            rotArr+=adjustedPos
            #Plot the detector boundary
            ax.plot(rotArr[:,2],rotArr[:,0],label='Opening',linewidth=6,zorder=10)
        
        #Axes labels
        ax.set_xlabel('Z [m]')
        ax.set_ylabel('X [m]')
        
        #Subplot title
        ax.set_title('XZ Plane')
        
        #Zoom into the area with particle tracks
        if len(openingTracks)!=0:
            #x points of each track
            xVals=[openingTracks[i][0][:] for i in range(0,len(openingTracks))]                
            #Pad array with nan values
            xVals=pad_array(xVals)
            xMax=np.nanmax(xVals)
            xMin=np.nanmin(xVals)
            #z points of each track
            zVals=[openingTracks[i][2][:] for i in range(0,len(openingTracks))]
            #Pad array with nan values
            zVals=pad_array(zVals)
            zMax=np.nanmax(zVals)
            zMin=np.nanmin(zVals)
            
            ax.set_xlim(zMin-0.25,zMax+0.25)
            ax.set_ylim(xMin-0.05,xMax+0.05)
        
        ax.legend()
        ax.grid(True)

    #YZ plot
    if label=='upper left':
        
        #Plot each ray
        if len(openingTracks)!=0:
            for i in range(len(openingTracks)):
                
                ax.plot(openingTracks[i][2],openingTracks[i][1],color='red')
            
                #Plot the endpoints
                #Only add label to 1 track
                if i==1:
                    ax.scatter(openingTracks[i][2][-1],openingTracks[i][1][-1],zorder=5,color='blue',label='End Point')
                else:
                    ax.scatter(openingTracks[i][2][-1],openingTracks[i][1][-1],zorder=5,color='blue')
                #Plot the startpoints
                #Only add label to 1 track
                if i==1:
                    ax.scatter(openingTracks[i][2][0],openingTracks[i][1][0],s=75,zorder=5,color='black',label='Start Point')
                else:
                    ax.scatter(openingTracks[i][2][0],openingTracks[i][1][0],s=75,zorder=5,color='black')
        
        #Plot the poloidal flux
        #Plot limits
        psilim=eqDict['psi_lim']
        #Plot levels
        levels=np.linspace(0,psilim,40)
        
        pltobj=ax.contour(Zmesh,Rmesh,eqdsk_psi,levels=levels)
        pltobj=ax.contour(Zmesh,-Rmesh,eqdsk_psi,levels=levels)
        
        #Plot the detector
        if type(detectorLoc)!=int:
            
            #Detector normal
            ax.quiver(detectorLoc[2],detectorLoc[1],detectorVec[2],detectorVec[1],width=3e-3,zorder=10)
            # ax.quiverkey(detNormalObj,0.9,0.9,1,label='Detector Normal',labelpos='E')
            
            #Detector boundary
            #100 points on a unit circle in the xy-plane
            detPosArr=np.array([np.cos(np.linspace(0,2*np.pi,100)),np.sin(np.linspace(0,2*np.pi,100)),np.zeros(100)])
            #Scale unit circle to detector size
            detPosArr*=np.sqrt(detectorArea/np.pi)
            #Angles by which to rotate this circle based on the detector normal
            theta=np.arccos(detectorVec[2])
            phi=np.arctan2(detectorVec[1],detectorVec[0])
            #Initialize the rotation
            rotObj=R.from_euler('ZYX',[phi,theta,0])
            #Apply the rotation to each point
            rotArr=[]
            for i in range(len(detPosArr[0])):
                rotArr.append(rotObj.apply(detPosArr[:,i]))
            rotArr=np.array(rotArr)
            #Move to the detector location
            rotArr+=detectorLoc
            #Plot the detector boundary
            ax.plot(rotArr[:,2],rotArr[:,1],label='Detector',linewidth=6,zorder=10)
            
        #Plot the tube opening
        if type(adjustedPos)!=int:
            
            #Detector normal
            ax.quiver(adjustedPos[2],adjustedPos[1],openNorm[2],openNorm[1],width=3e-3,zorder=10)
            # ax.quiverkey(detNormalObj,0.9,0.9,1,label='Detector Normal',labelpos='E')
            
            #Detector boundary
            #100 points on a unit circle in the xy-plane
            detPosArr=np.array([np.cos(np.linspace(0,2*np.pi,100)),np.sin(np.linspace(0,2*np.pi,100)),np.zeros(100)])
            #Scale unit circle to detector size
            detPosArr*=np.sqrt(detectorArea/np.pi)
            #Angles by which to rotate this circle based on the detector normal
            theta=np.arccos(openNorm[2])
            phi=np.arctan2(openNorm[1],openNorm[0])            
            #Initialize the rotation
            rotObj=R.from_euler('ZYX',[phi,theta,0])
            #Apply the rotation to each point
            rotArr=[]
            for i in range(len(detPosArr[0])):
                rotArr.append(rotObj.apply(detPosArr[:,i]))
            rotArr=np.array(rotArr)
            #Move to the detector location
            rotArr+=adjustedPos
            #Plot the detector boundary
            ax.plot(rotArr[:,2],rotArr[:,1],label='Opening',linewidth=6,zorder=10)
        
        ax.set_xlabel('Z [m]')
        ax.set_ylabel('Y [m]')
        
        #Subplot title
        ax.set_title('YZ Plane')
        
        #Zoom into the area with particle tracks
        if len(openingTracks)!=0:
            #x points of each track
            xVals=[openingTracks[i][1][:] for i in range(0,len(openingTracks))]                
            #Pad array with nan values
            xVals=pad_array(xVals)
            xMax=np.nanmax(xVals)
            xMin=np.nanmin(xVals)
            #z points of each track
            zVals=[openingTracks[i][2][:] for i in range(0,len(openingTracks))]
            #Pad array with nan values
            zVals=pad_array(zVals)
            zMax=np.nanmax(zVals)
            zMin=np.nanmin(zVals)
            
            ax.set_xlim(zMin-0.25,zMax+0.25)
            ax.set_ylim(xMin-0.05,xMax+0.05)
        
        ax.legend()
        ax.grid(True)

    #XY plot
    if label=='right':
        
        #Plot each ray
        if len(openingTracks)!=0:
            for i in range(len(openingTracks)):
                
                ax.plot(openingTracks[i][0],openingTracks[i][1],color='red')
            
                #Plot the endpoints
                #Only add label to 1 track
                if i==1:
                    ax.scatter(openingTracks[i][0][-1],openingTracks[i][1][-1],zorder=5,color='blue',label='End Point')
                else:
                    ax.scatter(openingTracks[i][0][-1],openingTracks[i][1][-1],zorder=5,color='blue')
                #Plot the startpoints
                #Only add label to 1 track
                if i==1:
                    ax.scatter(openingTracks[i][0][0],openingTracks[i][1][0],s=75,zorder=5,color='black',label='Start Point')
                else:
                    ax.scatter(openingTracks[i][0][0],openingTracks[i][1][0],s=75,zorder=5,color='black')
        
        #Plot the r=10cm circle
        #Create the circle object
        circ=plt.Circle((0,0),  #Center
                  0.1,          #Radius in m
                  color='g',    #Color
                  linewidth=5,  #Line width
                  fill=False)   #Only make an outline
        #Add to the plot
        ax.add_patch(circ)
        
        #Plot the detector
        if type(detectorLoc)!=int:
            
            #Detector normal
            ax.quiver(detectorLoc[0],detectorLoc[1],detectorVec[0],detectorVec[1],width=3e-3,zorder=10)
            # ax.quiverkey(detNormalObj,0.9,0.9,1,label='Detector Normal',labelpos='E')
            
            #Detector boundary
            #100 points on a unit circle in the xy-plane
            detPosArr=np.array([np.cos(np.linspace(0,2*np.pi,100)),np.sin(np.linspace(0,2*np.pi,100)),np.zeros(100)])
            #Scale unit circle to detector size
            detPosArr*=np.sqrt(detectorArea/np.pi)
            #Angles by which to rotate this circle based on the detector normal
            theta=np.arccos(detectorVec[2])
            phi=np.arctan2(detectorVec[1],detectorVec[0])
            #Initialize the rotation
            rotObj=R.from_euler('ZYX',[phi,theta,0])
            #Apply the rotation to each point
            rotArr=[]
            for i in range(len(detPosArr[0])):
                rotArr.append(rotObj.apply(detPosArr[:,i]))
            rotArr=np.array(rotArr)
            #Move to the detector location
            rotArr+=detectorLoc
            #Plot the detector boundary
            ax.plot(rotArr[:,0],rotArr[:,1],label='Detector',linewidth=6,zorder=10)
            
        #Plot the tube opening
        if type(adjustedPos)!=int:
            
            #Detector normal
            ax.quiver(adjustedPos[0],adjustedPos[1],openNorm[0],openNorm[1],width=3e-3,zorder=10)
            # ax.quiverkey(detNormalObj,0.9,0.9,1,label='Detector Normal',labelpos='E')
            
            #Detector boundary
            #100 points on a unit circle in the xy-plane
            detPosArr=np.array([np.cos(np.linspace(0,2*np.pi,100)),np.sin(np.linspace(0,2*np.pi,100)),np.zeros(100)])
            #Scale unit circle to detector size
            detPosArr*=np.sqrt(detectorArea/np.pi)
            #Angles by which to rotate this circle based on the detector normal
            theta=np.arccos(openNorm[2])
            phi=np.arctan2(openNorm[1],openNorm[0])
            #Initialize the rotation
            rotObj=R.from_euler('ZYX',[phi,theta,0])
            #Apply the rotation to each point
            rotArr=[]
            for i in range(len(detPosArr[0])):
                rotArr.append(rotObj.apply(detPosArr[:,i]))
            rotArr=np.array(rotArr)
            #Move to the detector location
            rotArr+=adjustedPos
            #Plot the detector boundary
            ax.plot(rotArr[:,0],rotArr[:,1],label='Opening',linewidth=6,zorder=10)
        
        ax.set_xlabel('X [m]')
        ax.set_ylabel('Y [m]')
        
        #Subplot title
        ax.set_title('XY Plane')
        
        #Zoom in to make plots clearer
        ax.set_xlim(-0.3,0.3)
        ax.set_ylim(-0.3,0.3)
        
        ax.legend()
        ax.grid(True)
        
    #Plot title
    fig.suptitle(r'$\theta$='+str(int(detTheta*180/np.pi))+r'$^{\circ}$; $\phi$='+str(int(detPhi*180/np.pi))+r'$^{\circ}$'+
                 r'; Bend Radius= '+str(bendRad)+'m; Tube Section= '+str(int(tubeAng*180/np.pi))+r'$^{\circ}$')

# =============================================================================
# Save the plot
# =============================================================================

#Get the name of the eqdsk file
ncName=filenameEqdsk.split('/')[-1]

#Generate the savename
savename=ncName+'_proton_detector_r_'+str(int(detPos[0]*100))+'cm_z_'+str(int(detPos[2]*100))+'cm_theta_'+str(int(detTheta*180/np.pi))+'deg_phi_'+str(int(detPhi*180/np.pi))+'deg_with_collimator.png'

#Save the plot
plt.savefig(plotDest+savename,bbox_inches='tight')

plt.show()

#%% Proton detector placement analysis (Rotating shaft scheme)

#Detector parameters

#Position (x,y,z)
detPos=np.array([0.15,0,0.2]) #meters

#Orientation
#alpha1 (angle wrt x axis)
alpha1=(np.pi/180)*180 #radians
#alpha2 (angle wrt y axis in the yz plane)
alpha2=(np.pi/180)*(0) #radians

#Size
detSize=25*1e-6 #m^2

#Acceptance angle
accAngle=(np.pi/180)*1

#Particle species
species='H'

#Normal vector of the detector
detNorm=np.array([np.cos(alpha1),np.sin(alpha1)*np.cos(alpha2),np.sin(alpha1)*np.sin(alpha2)])

#Calculate spherical coordinates
#Theta (angle wrt z axis)
detTheta=np.arccos(detNorm[2]) #radians
detPhi=np.arccos(detNorm[0]/np.sin(detTheta))

#Get the particle tracks
particleTracks=generate_tracks_detector(filenameEqdsk,detPos,detSize,detTheta,detPhi,accAngle,species=species)

#Array to store the tracks that reach the core
coreTracks=[]

#Radius of the core
coreRad=0.1 #meters

#Go over each particle track to see if it hits the detector
for i in range(len(particleTracks)):
    
    print('Track number- '+str(i+1))
    
    #Get the current track
    currTrack=particleTracks[i]
    
    #Check if the particle goes through the core
    throughTheCore,coreTrack=through_the_core(currTrack,coreRad)
    
    #Add the track to the array
    if throughTheCore==True:
        coreTracks.append(coreTrack)

#%% Plot the analysis

#Get the name of the eqdsk file
ncName=filenameEqdsk.split('/')[-1]

#Savename for the plots
# savename='_r_'+str(int(detPos[0]*100))+'cm.png'
# savenameXY='_r_'+str(int(detPos[0]*100))+'cm_XY.png'
# savename='_alpha2_'+str(int(alpha2*180/np.pi))+'deg.png'
savename=ncName+'_proton_detector_r_'+str(int(detPos[0]*100))+'cm_z_'+str(int(detPos[2]*100))+'cm_theta_'+str(int(detTheta*180/np.pi))+'deg_phi_'+str(int(detPhi*180/np.pi))+'deg.png'

#3D plot
# plot_particle_tracks(coreTracks,endpoints=True,startpoints=True,detectorLoc=detPos,detectorVec=detNorm,detectorArea=detSize,make3d=True)

#2D plots
plot_particle_tracks(coreTracks,endpoints=True,startpoints=True,detectorLoc=detPos,detectorVec=detNorm,detectorArea=detSize,savename=savename,saveplot=True)

#%% Multiple particles, multiple launch points

#Particle species
species='H'

#Number of z positions
zPos=10
#Number of theta positions
thetaPos=15

#Initial positions
xIniArr=np.transpose([np.zeros(zPos),np.zeros(zPos),np.linspace(-0.75,0.75,zPos)])

#Initial energy and angles
energy=fusion_energy(species)
thetaArr=np.linspace(0,2*np.pi,thetaPos)

#eqdsk data object
eqDict=eqTools.read_eqdsk(filenameEqdsk)

#Flux surface data
Rmesh,Zmesh,eqdsk_psi=eqTools.flux_surfaces(filenameEqdsk)

#Get the particle tracks
particleTracks=[]
#Go over each launch position
for i in range(zPos):
    #Go over each theta angle
    for j in range(thetaPos):
        
        #Single particle track
        stateVec=single_particle_track(xIni=xIniArr[i],energy=energy,theta=thetaArr[j])
        #Add track to the array
        particleTracks.append(stateVec)
    
#Convert to numpy
particleTracks=np.array(particleTracks)

#Create the plot
fig=plt.figure(figsize=(21,8))
ax=fig.add_subplot(111)

#Plot the poloidal flux
#Plot limits
psilim=eqDict['psi_lim']
#Plot levels
levels=np.linspace(0,psilim,40)

pltobj=ax.contour(Zmesh,Rmesh,eqdsk_psi,levels=levels)
pltobj=ax.contour(Zmesh,-Rmesh,eqdsk_psi,levels=levels)
cbar=fig.colorbar(pltobj)
cbar.set_label(r'$\Psi_B$ [$T \cdot m^2$]')

#Number of particles
numParticles=np.shape(particleTracks)[0]
#Evenly spaced array for chaning colors
colorArr=np.linspace(0,1,numParticles)
#Plot each ray
for i in range(numParticles):
    ax.plot(particleTracks[i][2],particleTracks[i][1],color=(colorArr[i],0,0))

ax.set_xlabel('Z [m]')
ax.set_ylabel('X [m]')

ax.set_xlim(np.min(Zmesh),np.max(Zmesh))
ax.set_ylim(-np.max(Rmesh),np.max(Rmesh))

ax.grid(True)

plt.show()

#%% Multiple particles, single launch point

#Particle species
species='H'

#Initial position
xIni=[0,0,0.58]

#Initial energy and angles
energy=fusion_energy(species)
thetaArr=np.linspace(0,2*np.pi,200)

#eqdsk data object
eqDict=eqTools.read_eqdsk(filenameEqdsk)

#Flux surface data
Rmesh,Zmesh,eqdsk_psi=eqTools.flux_surfaces(filenameEqdsk)

#Get the particle tracks
particleTracks=[]
for i in range(len(thetaArr)):
    
    #Single particle track
    stateVec=single_particle_track(xIni=xIni,energy=energy,theta=thetaArr[i])
    
    particleTracks.append(stateVec)
    
#Convert to numpy
particleTracks=np.array(particleTracks)

#Plot the tracks
plot_particle_tracks(particleTracks,endpoints=True,startpoints=True)

#%% Single particle test

#Particle species
species='H'

#Initial position
xIni=np.array([0,0,0.58])

#Initial energy and angles
energy=fusion_energy(species)
theta=np.pi/4

#eqdsk data object
eqDict=eqTools.read_eqdsk(filenameEqdsk)

#Flux surface data
Rmesh,Zmesh,eqdsk_psi=eqTools.flux_surfaces(filenameEqdsk)

#Get the particle track
stateVec=single_particle_track(xIni=xIni,energy=energy,theta=theta)

#Create the plot
fig=plt.figure(figsize=(21,8))
ax=fig.add_subplot(111)

#Plot the poloidal flux
#Plot limits
psilim=eqDict['psi_lim']
#Plot levels
levels=np.linspace(0,psilim,40)

pltobj=ax.contour(Zmesh,Rmesh,eqdsk_psi,levels=levels)
pltobj=ax.contour(Zmesh,-Rmesh,eqdsk_psi,levels=levels)
cbar=fig.colorbar(pltobj)
cbar.set_label(r'$\Psi_B$ [$T \cdot m^2$]')

ax.plot(stateVec[2],stateVec[1],label='Particle Track')

ax.set_xlabel('Z [m]')
ax.set_ylabel('X [m]')

ax.grid(True)
ax.legend()

plt.show()

#%% Proton detector placement analysis (Old)

#This code block relied on a set of fusion protons launched from r=0 along the
#z axis and the detector postion was changed. The new version launches fusion
#particles from the detector directly.

#Location of the CQL3D output
filename='C:/Users/kunal/OneDrive - UW-Madison/WHAM/Data/CQL3D/220310_rf_250kW.nc'

#Scale output to cql3d data
scaleOutput=True

#Detector parameters

#Position
detPos=np.array([0.1,0,0]) #meters

#Orientation
#Theta (angle wrt z axis) (0 is radially outwards in cylindrical coordinates)
detTheta=np.pi/2 #radians
#Phi (angle wrt x axis)
detPhi=np.pi #radians

#Size
detSize=5000*1e-6 #m^2

#Acceptance angle
accAngle=np.pi/4

#Normal vector of the detector
detNorm=np.array([np.sin(detTheta)*np.cos(detPhi),np.sin(detTheta)*np.sin(detPhi),np.cos(detTheta)])

#Particle species
species='H'

#eqdsk data object
eqDict=eqTools.read_eqdsk(filenameEqdsk)

#Flux surface data
Rmesh,Zmesh,eqdsk_psi=eqTools.flux_surfaces(filenameEqdsk)

#Get the particle tracks
particleTracks=[]

if scaleOutput==True:
    
    #Get the name of the cql3d .nc file
    ncName=filename.split('/')[-1]
    #Remove the .nc part
    ncName=ncName[0:-3]
    savename=ncName+'_particleTracks.npy'
    #Load the data
    try:
        particleTracks=np.load('C:/Users/kunal/OneDrive - UW-Madison/WHAM/Data/'+savename)
    except:
        particleTracks=generate_tracks_cql3d(filename,species=species)

else:
    #Get the name of the eqdsk .nc file
    ncName=filenameEqdsk.split('/')[-1]
    #Remove the .nc part
    ncName=ncName[0:-3]
    savename=ncName+'_particleTracks.npy'
    #Load the data
    try:
        particleTracks=np.load('C:/Users/kunal/OneDrive - UW-Madison/WHAM/Data/'+savename)
    except:
        particleTracks=generate_tracks_eqdsk(filenameEqdsk,species=species)
        
#Convert to numpy
particleTracks=np.array(particleTracks)

#Plot all the particles
# plot_particle_tracks(particleTracks)

#Array to store the tracks that hit the detector
contactTracks=[]

#Go over each particle track to see if it hits the detector
for i in range(len(particleTracks)):
    
    print('Track number- '+str(i+1))
    
    #Get the current track
    currTrack=particleTracks[i]
    
    #Go over the current track
    for j in range(len(currTrack[0])-1):
        
        #Position of the particle
        point1=currTrack[0:3,j]
        
        #Check if the track hits the wall
        if hit_vessel(point1)==True:
            #No need to track if the particle hits the vessel
            break
        
        #Next point to define a line segment to test intersection
        point2=currTrack[0:3,j+1]
        
        #Check if the line intersects the plane
        intPoint=line_plane_intersection(point1,point2,detPos,detNorm)
        if type(intPoint)==np.ndarray:
            
            #Check if the point of intersection is close to the track and detector
            onLine=close_to_line(intPoint,point1,point2)
            onDetector=close_to_detector(intPoint,detSize,detPos)
            if onLine==True and onDetector==True:
                
                #Check if it hit the right face of the detector
                if correct_face(currTrack[:,j],detNorm)==True:
                    
                    #Check if it hit at the right angle
                    impactAngle,correctAngle=acceptance_angle(currTrack[:,j],detNorm,accAngle)
                    if correctAngle==True:
                
                        #Only add the part upto the hit
                        contactTracks.append(currTrack[:,:j+1])
                    
                        #No need to track further if the particle hits the detector
                        break
                    
                    #Stop tracking if it hits at the wrong angle
                    else:
                        break
                
                #Stop tracking if it hits the wrong face
                else:
                    break
                
#Savename
#Get the name of the cql3d .nc file
ncName=filename.split('/')[-1]
#Remove the .nc part
ncName=ncName[0:-3]
savename=ncName+'_theta_'+str(np.round(detTheta))+'_phi_'+str(np.round(detPhi))+'.png'
#Plot the tracks that hit the detector
plot_particle_tracks(contactTracks,detectorLoc=detPos,detectorVec=detNorm,detectorArea=detSize,savename='',saveplot=True)
                
#%% Deugging

#Get the starting positions and velocities of the particles
startState=particleTracks[:,:,0]

#Initial velocities
vxIni=startState[:,3]
vyIni=startState[:,4]
vzIni=startState[:,5]

#Get the average velocities
vxAvg=np.average(vxIni)
vyAvg=np.average(vyIni)
vzAvg=np.average(vzIni)

#%% Arc length

currArcLen=0.3*np.pi/15

newRad=0.5

newAng=currArcLen/newRad

print(newAng)